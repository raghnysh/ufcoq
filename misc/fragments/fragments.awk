### Get data about fragments in files

## Usage:
##
##   awk -f fragments.awk file...
##
## Print to standard output data about fragments in the given files.
##
## A fragment is a piece of text delimited at the top by a line
## containing a string of the form "begfrag:label", and at the bottom
## by a line containing a string of the form "endfrag".  The suffix
## label must be a string consisting of letters, digits, and the
## hyphen character.
##
## The data is printed as a recutils database with the following
## record descriptor:
##
## %key: Label
## %sort: SortKey Name File Begin
## %doc: Fragments from files
## + Label: a unique identifier for the fragment
## + Name: the name of the main object of the fragment if applicable else NA
## + Class: the category of the main object of the fragment
## + File: the file containing the fragment
## + Begin: the number in the file of the first line of the fragment
## + End: the number in the file of the last line of the fragment
## + Content: the text of the fragment
## + LHS: the left hand side of the first := in Content if applicable else NA
## + RHS: the right hand side of the first := in Content if applicable else NA
## + Arguments: the Arguments for the fragment if applicable else NA
## + SortKey: a string used for sorting the records
##
## I assume that this script will be run with gawk although I am not
## using any special gawk features here and any POSIX compliant awk
## should do.  Just being prudent.

### ==================================================================
### The line processor
### ==================================================================

BEGIN {
    initialise()
}

{
    process_line()
}

END {
    finalise()
}

### ==================================================================
### Function definitions
### ==================================================================

## Local variables are declared as parameters with names having the
## prefix "l_".

function initialise() {
    ## Regular expression that matches the opening string of a
    ## fragment begin tag.
    fragment_begin_tag_prefix = "^.*begfrag:"

    ## Regular expression that matches the closing string of a
    ## fragment begin tag.
    fragment_begin_tag_suffix = "[^[:digit:][:alpha:]-]*$"

    ## Regular expression that matches the opening string of a
    ## fragment end tag.
    fragment_end_tag_prefix = "^.*endfrag"
    ## Regular expression that matches the closing string of a
    ## fragment end tag.
    fragment_end_tag_suffix = fragment_begin_tag_suffix

    ## The current number of fragments.
    fragment_count = 0

    return 0
}

function process_line() {
    if (is_fragment_begin_tag_line($0))
        process_fragment_begin_tag_line()

    if (is_fragment_blank_line($0))
        process_fragment_blank_line()

    if (is_fragment_line($0))
        process_fragment_line()

    if (is_fragment_end_tag_line($0))
        process_fragment_end_tag_line()

    return 0
}

function finalise(l_index, l_output) {
    l_output = "### Recutils database for fragments from files\n\
\n\
## This file is automatically generated.  Do not edit it.\n\
\n\
%%rec: Fragment\n\
%%key: Label\n\
%%sort: SortKey Name File Begin\n\
%%doc: Fragments from files\n\
+ Label: a unique identifier for the fragment\n\
+ Name: the name of the main object of the fragment if applicable else NA\n\
+ Class: the category of the main object of the fragment\n\
+ File: the file containing the fragment\n\
+ Begin: the number in the file of the first line of the fragment\n\
+ End: the number in the file of the last line of the fragment\n\
+ Content: the text of the fragment\n\
+ LHS: the left hand side of the first := in Content if applicable else NA\n\
+ RHS: the right hand side of the first := in Content if applicable else NA\n\
+ Arguments: the Arguments declarations in the fragment if applicable else NA\n\
+ SortKey: a string used for sorting the records\n"

    for (l_index = 1; l_index <= fragment_count; l_index++) {
        l_output = l_output \
            generate_fragment_data( \
                fragment_labels_table[l_index], \
                fragment_files_table[l_index], \
                fragment_beginnings_table[l_index], \
                fragment_endings_table[l_index], \
                fragment_contents_table[l_index])
    }

    l_output = l_output "\n### End of file\n"

    printf(l_output)

    return 0
}

function is_fragment_begin_tag_line(string) {
    return string ~ fragment_begin_tag_prefix
}

function is_fragment_blank_line(string) {
    return string ~ "^[[:space:]]*$" && in_fragment == "yes"
}

function is_fragment_line(string) {
    return \
        ! is_fragment_begin_tag_line(string)  && \
        ! is_fragment_end_tag_line(string) && \
        in_fragment == "yes"
}

function is_fragment_end_tag_line(string) {
    return string ~ fragment_end_tag_prefix
}

function process_fragment_begin_tag_line() {
    in_fragment = "yes"
    fragment_count = fragment_count + 1
    fragment_labels_table[fragment_count] = \
        fragment_label_from_string($0)
    fragment_files_table[fragment_count] = FILENAME
    fragment_beginnings_table[fragment_count] = FNR + 1

    ## https://www.gnu.org/software/gawk/manual/html_node/Delete.html
    ## https://www.austingroupbugs.net/view.php?id=544
    delete fragment_blanks_table

    return 0
}

function process_fragment_blank_line() {
    fragment_blanks_table[FNR] = fragment_label

    return 0
}

function process_fragment_line() {
    old = fragment_contents_table[fragment_count]
    fragment_contents_table[fragment_count] = sprintf("%s%s\n",
                                                      old,
                                                      $0)

    return 0
}

function process_fragment_end_tag_line(l_begin, l_end) {
    in_fragment = "no"
    fragment_endings_table[fragment_count] = FNR - 1

    l_begin = fragment_beginnings_table[fragment_count]
    while (l_begin in fragment_blanks_table)
        l_begin = l_begin + 1
    fragment_beginnings_table[fragment_count] = l_begin

    l_end = fragment_endings_table[fragment_count]
    while (l_end in fragment_blanks_table)
        l_end = l_end - 1
    fragment_endings_table[fragment_count] = l_end

    return 0
}

function fragment_label_from_string(string) {
    gsub(fragment_begin_tag_prefix, "", string)
    gsub(fragment_begin_tag_suffix, "", string)
    gsub(fragment_end_tag_prefix, "", string)
    gsub(fragment_end_tag_suffix, "", string)

    return string
}

function generate_fragment_data(label, file, begin, end, content) {
    sub("^[\n[:space:]]*", "", content)
    sub("[\n[:space:]]*$", "", content)

    rhs_begin = index(content, ":=")

    if (rhs_begin > 0) {
        lhs = substr(content, 1, rhs_begin - 1)
        sub("[\n[:space:]]*$", "", lhs)

        rhs = substr(content, rhs_begin)
        sub("^:=[\n[:space:]]*", "", rhs)

        class_pattern = \
            "^[[:space:]]*" \
            "(Definition|Example|Inductive|Record|Notation)" \
            ".*"
        class = gensub(class_pattern, "\\1", 1, lhs)

        notation_pattern = \
            ".*" \
            "Notation" \
            "[[:space:]]+" \
            "(.*)"

        if (class ~ "Notation")
            name = gensub(notation_pattern, "\\1", 1, lhs)

        definition_pattern = \
            ".*" \
            "(Definition|Example|Inductive|Record)" \
            "[[:space:]]+" \
            "([^[:space:]:]+)" \
            ".*"

        if (class ~ "(Definition|Example|Inductive|Record)")
            name = gensub(definition_pattern, "\\2", 1, lhs)
    }

    if (rhs_begin <= 0) {
        lhs = "NA"
        rhs = "NA"
        class = "Vernacular"
        name = "NA"
    }

    if (class ~ "Definition")
        sortkey = "A"

    if (class ~ "Inductive")
        sortkey = "D"

    if (class ~ "Record")
        sortkey = "G"

    if (class ~ "Notation")
        sortkey = "J"

    if (class ~ "Vernacular")
        sortkey = "T"

    if (class ~ "Example")
        sortkey = "Z"

    arguments_begin = index(content, "Arguments")

    if (arguments_begin > 0) {
        arguments = substr(content, arguments_begin)
    }
    else {
        arguments = "NA"
    }

    gsub("\n", "\\n", content)
    gsub("\n", "\\n", lhs)
    gsub("\n", "\\n", rhs)
    gsub("\n", "\\n", arguments)

    label_field = sprintf("\nLabel: %s", label)
    name_field = sprintf("\nName: %s", name)
    class_field = sprintf("\nClass: %s", class)
    file_field = sprintf("\nFile: %s", file)
    begin_field = sprintf("\nBegin: %s", begin)
    end_field = sprintf("\nEnd: %s", end)
    content_field = sprintf("\nContent: %s", content)
    lhs_field = sprintf("\nLHS: %s", lhs)
    rhs_field = sprintf("\nRHS: %s", rhs)
    arguments_field = sprintf("\nArguments: %s", arguments)
    sortkey_field = sprintf("\nSortKey: %s", sortkey)

    return \
        label_field \
        name_field \
        class_field \
        file_field \
        begin_field \
        end_field \
        content_field \
        lhs_field \
        rhs_field \
        arguments_field \
        sortkey_field \
        "\n"
}

### End of file

# Local Variables:
# c-auto-align-backslashes: nil
# End:
