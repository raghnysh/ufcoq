### Recutils database for fragments from files

## This file is automatically generated.  Do not edit it.

%rec: Fragment
%key: Label
%sort: SortKey Name File Begin
%doc: Fragments from files
+ Label: a unique identifier for the fragment
+ Name: the name of the main object of the fragment if applicable else NA
+ Class: the category of the main object of the fragment
+ File: the file containing the fragment
+ Begin: the number in the file of the first line of the fragment
+ End: the number in the file of the last line of the fragment
+ Content: the text of the fragment
+ LHS: the left hand side of the first := in Content if applicable else NA
+ RHS: the right hand side of the first := in Content if applicable else NA
+ SortKey: a string used for sorting the records

Label: zf4f204h
Name: NA
Class: Vernacular
File: src/base/construct.v
Begin: 8
End: 8
Content: Require Import ufcoq.base.primitive.
LHS: NA
RHS: NA
SortKey: T

Label: b5b085qn
Name: Kind
Class: Definition
File: src/base/construct.v
Begin: 16
End: 19
Content: LHS := RHS
LHS: Definition Kind : forall (X : Type), X -> Type
RHS: fun (X : Type) (x : X) => X.
+
+    Arguments Kind {X} _.
SortKey: A

Label: yrbfo0qa
Name: FunctionDomain
Class: Definition
File: src/base/construct.v
Begin: 27
End: 31
Content: LHS := RHS
LHS: Definition FunctionDomain
+      : forall (X : Type) (F : X -> Type), (forall (x : X), F x) -> Type
RHS: fun (X : Type) (F : X -> Type) (f : forall (x : X), F x) => X.
+
+    Arguments FunctionDomain {X} {F} _.
SortKey: A

Label: qolnxg6a
Name: FunctionCodomain
Class: Definition
File: src/base/construct.v
Begin: 35
End: 41
Content: LHS := RHS
LHS: Definition FunctionCodomain
+      : forall (X : Type) (F : X -> Type),
+          (forall (x : X), F x) -> X -> Type
RHS: fun (X : Type) (F : X -> Type)
+           (f : forall (x : X), F x) (a : X) => F a.
+
+    Arguments FunctionCodomain {X} {F} _ _.
SortKey: A

Label: jezpb6sa
Name: function_value
Class: Definition
File: src/base/construct.v
Begin: 45
End: 51
Content: LHS := RHS
LHS: Definition function_value
+      : forall (X : Type) (F : X -> Type) (a : X),
+          (forall (x : X), F x) -> F a
RHS: fun (X : Type) (F : X -> Type) (a : X)
+           (f : forall (x : X), F x) => f a.
+
+    Arguments function_value {X} {F} a _.
SortKey: A

Label: u4wjel9o
Name: function_compose
Class: Definition
File: src/base/construct.v
Begin: 55
End: 68
Content: LHS := RHS
LHS: Definition function_compose
+      : forall (X Y : Type)
+               (G : Y -> Type)
+               (g : forall (y : Y), G y)
+               (f : X -> Y),
+          forall (x : X), G (f x)
RHS: fun (X Y : Type)
+             (G : Y -> Type)
+             (g : forall (y : Y), G y)
+             (f : X -> Y)
+             (x : X)
+           => g (f x).
+
+    Arguments function_compose {X Y G} g f _.
SortKey: A

Label: ct7rwcsm
Name: identity_function
Class: Definition
File: src/base/construct.v
Begin: 72
End: 75
Content: LHS := RHS
LHS: Definition identity_function : forall (X : Type), X -> X
RHS: fun (X : Type) (x : X) => x.
+
+    Arguments identity_function {X} _.
SortKey: A

Label: q4yy6ynm
Name: constant_function
Class: Definition
File: src/base/construct.v
Begin: 79
End: 82
Content: LHS := RHS
LHS: Definition constant_function : forall (X Y : Type), Y -> X -> Y
RHS: fun (X Y : Type) (y : Y) (_ : X) => y.
+
+    Arguments constant_function {X Y} _ _.
SortKey: A

Label: 867thqwu
Name: functions_equal_values_equal
Class: Definition
File: src/base/construct.v
Begin: 86
End: 107
Content: LHS := RHS
LHS: Definition functions_equal_values_equal
+      : forall (X : Type)
+               (F : X -> Type)
+               (f g : forall (x : X), F x),
+          Equal f g -> forall (x : X), Equal (f x) (g x)
RHS: fun (X : Type)
+             (F : X -> Type)
+             (f : forall (x : X), F x)
+           =>
+             let
+               T : Type := forall (x : X), F x
+             in let
+               P : forall (t : T), Equal f t -> Type
+                 := fun (t : T)
+                      => constant_function
+                           (forall (x : X), Equal (f x) (t x))
+             in let
+               base : P f (reflexive f) := fun (x : X) => reflexive (f x)
+             in
+               equal_induction f P base.
+
+    Arguments functions_equal_values_equal {X F f g} _ x.
SortKey: A

Label: gcfsyi93
Name: false_recursion
Class: Definition
File: src/base/construct.v
Begin: 115
End: 117
Content: LHS := RHS
LHS: Definition false_recursion : forall (X : Type), False -> X
RHS: fun (X : Type)
+           => false_induction (@constant_function False Type X).
SortKey: A

Label: kad6krsx
Name: true_recursion
Class: Definition
File: src/base/construct.v
Begin: 121
End: 125
Content: LHS := RHS
LHS: Definition true_recursion : forall (X : Type), X -> True -> X
RHS: fun (X : Type)
+           => true_induction (@constant_function True Type X).
+
+    Arguments true_recursion {X} _ _.
SortKey: A

Label: cppabof7
Name: to_true
Class: Definition
File: src/base/construct.v
Begin: 129
End: 132
Content: LHS := RHS
LHS: Definition to_true : forall (X : Type), X -> True
RHS: fun (X : Type) => constant_function only.
+
+    Arguments to_true {X} _.
SortKey: A

Label: tav7tpv0
Name: boolean_recursion
Class: Definition
File: src/base/construct.v
Begin: 136
End: 141
Content: LHS := RHS
LHS: Definition boolean_recursion
+      : forall (X : Type), X -> X -> Boolean -> X
RHS: fun (X : Type)
+           => boolean_induction (@constant_function Boolean Type X).
+
+    Arguments boolean_recursion {X} _ _ _.
SortKey: A

Label: 8m7c7dml
Name: natural_recursion
Class: Definition
File: src/base/construct.v
Begin: 145
End: 150
Content: LHS := RHS
LHS: Definition natural_recursion
+      : forall (X : Type), X -> (Natural -> X -> X) -> Natural -> X
RHS: fun (X : Type) =>
+          natural_induction (@constant_function Natural Type X).
+
+    Arguments natural_recursion {X} _ _ _.
SortKey: A

Label: yhafxlw0
Name: natural_recursion_simple
Class: Definition
File: src/base/construct.v
Begin: 154
End: 159
Content: LHS := RHS
LHS: Definition natural_recursion_simple
+      : forall (X : Type), X -> (X -> X) -> Natural -> X
RHS: fun (X : Type) (x : X) (f : X -> X)
+           => natural_recursion x (@constant_function Natural (X -> X) f).
+
+    Arguments natural_recursion_simple {X} _ _ _.
SortKey: A

Label: szbmydj4
Name: transport
Class: Definition
File: src/base/construct.v
Begin: 163
End: 179
Content: LHS := RHS
LHS: Definition transport
+      : forall (X : Type) (F : X -> Type) (x y : X),
+          Equal x y -> F x -> F y
RHS: fun (X : Type)
+             (F : X -> Type)
+             (x : X)
+           =>
+             let
+               G : forall (a : X), Equal x a -> Type
+                 := fun (a : X) => constant_function (F x -> F a)
+             in let
+               base : G x (reflexive x)
+                 := @identity_function (F x)
+             in
+               equal_induction x G base.
+
+    Arguments transport {X} F {x y} _ _.
SortKey: A

Label: xsfz3fch
Name: transport_inverse
Class: Definition
File: src/base/construct.v
Begin: 183
End: 199
Content: LHS := RHS
LHS: Definition transport_inverse
+      : forall (X : Type) (F : X -> Type) (x y : X),
+          Equal x y -> F y -> F x
RHS: fun (X : Type)
+             (F : X -> Type)
+             (x : X)
+           =>
+             let
+               G : forall (a : X), Equal x a -> Type
+                 := fun (a : X) => constant_function (F a -> F x)
+             in let
+               base : G x (reflexive x)
+                 := @identity_function (F x)
+             in
+               equal_induction x G base.
+
+    Arguments transport_inverse {X} F {x y} _ _.
SortKey: A

Label: wlyu1bpv
Name: sigma_induction
Class: Definition
File: src/base/construct.v
Begin: 203
End: 216
Content: LHS := RHS
LHS: Definition sigma_induction
+      : forall (X : Type)
+               (F : X -> Type)
+               (G : (Sigma (x : X), F x) -> Type),
+          (forall (x : X) (y : F x), G (sigma F x y))
+            -> (forall (t : Sigma (x : X), F x), G t)
RHS: fun (X : Type)
+             (F : X -> Type)
+             (G : (Sigma (x : X), F x) -> Type)
+             (f : forall (x : X) (y : F x), G (sigma F x y))
+             (t : Sigma (x : X), F x)
+        => f (sigma1 t) (sigma2 t).
+
+    Arguments sigma_induction {X F G} _ _.
SortKey: A

Label: dq9dzz6c
Name: sigma_uncurry
Class: Definition
File: src/base/construct.v
Begin: 220
End: 228
Content: LHS := RHS
LHS: Definition sigma_uncurry
+      : forall (X : Type)
+               (F : X -> Type)
+               (G : (Sigma (x : X), F x) -> Type),
+          (forall (x : X) (y : F x), G (sigma F x y))
+            -> forall (t : Sigma (x : X), F x), G t
RHS: @sigma_induction.
+
+    Arguments sigma_uncurry {X F G} _ _.
SortKey: A

Label: gewpttx0
Name: sigma_curry
Class: Definition
File: src/base/construct.v
Begin: 232
End: 246
Content: LHS := RHS
LHS: Definition sigma_curry
+      : forall (X : Type)
+               (F : X -> Type)
+               (G : (Sigma (x : X), F x) -> Type),
+          (forall (t : Sigma (x : X), F x), G t)
+            -> forall (x : X) (y : F x), G (sigma F x y)
RHS: fun  (X : Type)
+              (F : X -> Type)
+              (G : (Sigma (x : X), F x) -> Type)
+              (g : forall (t : Sigma (x : X), F x), G t)
+              (x : X)
+              (y : F x)
+           => g (sigma F x y).
+
+    Arguments sigma_curry {X F G} _ _ _.
SortKey: A

Label: siygmnhf
Name: sigma_recursion
Class: Definition
File: src/base/construct.v
Begin: 250
End: 262
Content: LHS := RHS
LHS: Definition sigma_recursion
+      : forall (X : Type)
+               (F : X -> Type)
+               (Y : Type),
+          (forall (x : X), F x -> Y) -> (Sigma (x : X), F x) -> Y
RHS: fun (X : Type)
+             (F : X -> Type)
+             (Y : Type)
+             (f : forall (x : X), F x -> Y)
+             (t : Sigma (x : X), F x)
+           => f (sigma1 t) (sigma2 t).
+
+    Arguments sigma_recursion {X F} Y _ _.
SortKey: A

Label: 9ia68b8n
Name: Product
Class: Definition
File: src/base/construct.v
Begin: 270
End: 271
Content: LHS := RHS
LHS: Definition Product : Type -> Type -> Type
RHS: fun (X Y : Type) => Sigma (_ : X), Y.
SortKey: A

Label: c97wzdtw
Name: pair
Class: Definition
File: src/base/construct.v
Begin: 275
End: 279
Content: LHS := RHS
LHS: Definition pair : forall (X Y : Type), X -> Y -> Product X Y
RHS: fun (X Y : Type) (x : X) (y : Y)
+           => sigma (@constant_function X Type Y) x y.
+
+    Arguments pair {X Y} _ _.
SortKey: A

Label: 9eptwq6k
Name: first
Class: Definition
File: src/base/construct.v
Begin: 283
End: 286
Content: LHS := RHS
LHS: Definition first : forall (X Y : Type), Product X Y -> X
RHS: fun (X Y : Type) (t : Product X Y) => sigma1 t.
+
+    Arguments first {X Y} _.
SortKey: A

Label: og9uqzhe
Name: second
Class: Definition
File: src/base/construct.v
Begin: 290
End: 293
Content: LHS := RHS
LHS: Definition second : forall (X Y : Type), Product X Y -> Y
RHS: fun (X Y : Type) (t : Product X Y) => sigma2 t.
+
+    Arguments second {X Y} _.
SortKey: A

Label: ww805vp5
Name: product_induction
Class: Definition
File: src/base/construct.v
Begin: 297
End: 307
Content: LHS := RHS
LHS: Definition product_induction
+      : forall (X Y : Type) (F : Product X Y -> Type),
+          (forall (x : X) (y : Y), F (pair x y))
+            -> forall (t : Product X Y), F t
RHS: fun (X Y : Type)
+             (F : Product X Y -> Type)
+             (f : forall (x : X) (y : Y), F (pair x y))
+             (t : Product X Y)
+           => f (first t) (second t).
+
+    Arguments product_induction {X Y F} _ _.
SortKey: A

Label: e1hi7545
Name: uncurry
Class: Definition
File: src/base/construct.v
Begin: 311
End: 317
Content: LHS := RHS
LHS: Definition uncurry
+      : forall (X Y : Type) (F : Product X Y -> Type),
+          (forall (x : X) (y : Y), F (pair x y))
+            -> forall (t : Product X Y), F t
RHS: @product_induction.
+
+    Arguments uncurry {X Y F} _ _.
SortKey: A

Label: g6p35mq1
Name: curry
Class: Definition
File: src/base/construct.v
Begin: 321
End: 332
Content: LHS := RHS
LHS: Definition curry
+      : forall (X Y : Type) (F : Product X Y -> Type),
+          (forall (t : Product X Y), F t)
+            -> forall (x : X) (y : Y), F (pair x y)
RHS: fun (X Y : Type)
+             (F : Product X Y -> Type)
+             (g : forall (t : Product X Y), F t)
+             (x : X)
+             (y : Y)
+           => g (pair x y).
+
+    Arguments curry {X Y F} _ _ _.
SortKey: A

Label: 9cz79pdm
Name: product_recursion
Class: Definition
File: src/base/construct.v
Begin: 336
End: 343
Content: LHS := RHS
LHS: Definition product_recursion
+      : forall (X Y Z : Type), (X -> Y -> Z) -> Product X Y -> Z
RHS: fun (X Y Z : Type)
+             (f : X -> Y -> Z)
+             (t : Product X Y)
+           => f (first t) (second t).
+
+    Arguments product_recursion {X Y Z} _ _.
SortKey: A

Label: d0923l5s
Name: PairFamily
Class: Definition
File: src/base/construct.v
Begin: 347
End: 352
Content: LHS := RHS
LHS: Definition PairFamily
+      : forall (T : Type), (T -> Type) -> (T -> Type) -> T -> Type
RHS: fun (T : Type) (F : T -> Type) (G : T -> Type) (t : T)
+           => Product (F t) (G t).
+
+    Arguments PairFamily {T} _ _ _.
SortKey: A

Label: rgjbl4r2
Name: pair_function
Class: Definition
File: src/base/construct.v
Begin: 356
End: 371
Content: LHS := RHS
LHS: Definition pair_function
+      : forall (T : Type)
+               (F : T -> Type)
+               (G : T -> Type),
+          (forall (t : T), F t)
+            -> (forall (t : T), G t)
+              -> forall (t : T), Product (F t) (G t)
RHS: fun (T : Type)
+             (F : T -> Type)
+             (G : T -> Type)
+             (f : forall (t : T), F t)
+             (g : forall (t : T), G t)
+             (t : T)
+           => pair (f t) (g t).
+
+    Arguments  pair_function {T F G} _ _ _.
SortKey: A

Label: wqs9857v
Name: product_map
Class: Definition
File: src/base/construct.v
Begin: 375
End: 384
Content: LHS := RHS
LHS: Definition product_map
+      : forall (X Y X' Y' : Type),
+          (X -> X') -> (Y -> Y') -> Product X Y -> Product X' Y'
RHS: fun (X Y X' Y' : Type)
+             (f : X -> X')
+             (g : Y -> Y')
+             (t : Product X Y)
+           => pair (f (first t)) (g (second t)).
+
+    Arguments product_map {X Y X' Y'} _ _ _.
SortKey: A

Label: fp5x8226
Name: Sum
Class: Definition
File: src/base/construct.v
Begin: 392
End: 395
Content: LHS := RHS
LHS: Definition Sum : Type -> Type -> Type
RHS: fun (X Y : Type)
+           => let F : Boolean -> Type := boolean_recursion X Y
+              in Sigma (b : Boolean), F b.
SortKey: A

Label: kknkg0c7
Name: left
Class: Definition
File: src/base/construct.v
Begin: 399
End: 402
Content: LHS := RHS
LHS: Definition left : forall (X Y : Type), X -> Sum X Y
RHS: fun (X Y : Type) (x : X) => sigma (boolean_recursion X Y) yes x.
+
+    Arguments left {X Y} _.
SortKey: A

Label: ma104yei
Name: right
Class: Definition
File: src/base/construct.v
Begin: 406
End: 409
Content: LHS := RHS
LHS: Definition right : forall (X Y : Type), Y -> Sum X Y
RHS: fun (X Y : Type) (y : Y) => sigma (boolean_recursion X Y) no y.
+
+    Arguments right {X Y} _.
SortKey: A

Label: hrr9zb80
Name: sum_induction
Class: Definition
File: src/base/construct.v
Begin: 413
End: 434
Content: LHS := RHS
LHS: Definition sum_induction
+      : forall (X Y : Type) (F : Sum X Y -> Type),
+          (forall (x : X), F (left x)) -> (forall (y : Y), F (right y))
+            -> forall (s : Sum X Y), F s
RHS: fun (X Y : Type)
+             (F : Sum X Y -> Type)
+             (f : forall (x : X), F (left x))
+             (g : forall (y : Y), F (right y))
+             (s : Sum X Y)
+           =>
+             let
+               P : Boolean -> Type := boolean_recursion X Y
+             in let
+               Q : Boolean -> Type
+                 := fun (b : Boolean)
+                      => forall (e : P b), F (sigma P b e)
+             in let
+               q : forall (b : Boolean), Q b := boolean_induction Q f g
+             in
+               q (sigma1 s) (sigma2 s).
+
+    Arguments sum_induction {X Y} F _ _ s.
SortKey: A

Label: czz2aznf
Name: sum_recursion
Class: Definition
File: src/base/construct.v
Begin: 438
End: 454
Content: LHS := RHS
LHS: Definition sum_recursion
+      : forall (X Y Z : Type), (X -> Z) -> (Y -> Z) -> Sum X Y -> Z
RHS: fun (X Y Z : Type)
+             (f : X -> Z)
+             (g : Y -> Z)
+             (s : Sum X Y)
+           =>
+             let
+               P : Boolean -> Type := boolean_recursion X Y
+             in let
+               Q : Boolean -> Type := fun (b : Boolean) => P b -> Z
+             in let
+               q : forall (b : Boolean), Q b := boolean_induction Q f g
+             in
+               q (sigma1 s) (sigma2 s).
+
+    Arguments sum_recursion {X Y Z} _ _ s.
SortKey: A

Label: mrbbbxn0
Name: sum_map
Class: Definition
File: src/base/construct.v
Begin: 458
End: 470
Content: LHS := RHS
LHS: Definition sum_map
+      : forall (X Y X' Y' : Type),
+          (X -> X') -> (Y -> Y') -> Sum X Y -> Sum X' Y'
RHS: fun (X Y X' Y' : Type) (f : X -> X') (g : Y -> Y')
+           =>
+             let
+               u : X -> Sum X' Y' := fun x => left (f x)
+             in let
+               v : Y -> Sum X' Y' := fun y => right (g y)
+             in
+               sum_recursion u v.
+
+    Arguments sum_map {X Y X' Y'} _ _ _.
SortKey: A

Label: ave0dtr6
Name: "X -> Y"
Class: Notation
File: src/base/primitive.v
Begin: 8
End: 9
Content: LHS := RHS
LHS: Notation "X -> Y"
RHS: (forall (_ : X), Y)
+      (at level 99, right associativity, Y at level 200).
SortKey: J

Label: 776l3lwg
Name: False
Class: Inductive
File: src/base/primitive.v
Begin: 17
End: 17
Content: LHS := RHS
LHS: Inductive False: Type
RHS: .
SortKey: D

Label: b79a8cj0
Name: false_induction
Class: Definition
File: src/base/primitive.v
Begin: 21
End: 23
Content: LHS := RHS
LHS: Definition false_induction
+      : forall (F : False -> Type) (x : False), F x
RHS: False_rect.
SortKey: A

Label: 815by4qc
Name: True
Class: Inductive
File: src/base/primitive.v
Begin: 31
End: 31
Content: LHS := RHS
LHS: Inductive True : Type
RHS: only : True.
SortKey: D

Label: xfdlpg97
Name: true_induction
Class: Definition
File: src/base/primitive.v
Begin: 35
End: 37
Content: LHS := RHS
LHS: Definition true_induction
+      : forall (F : True -> Type), F only -> forall (x : True), F x
RHS: True_rect.
SortKey: A

Label: 2xu2p4rk
Name: Boolean
Class: Inductive
File: src/base/primitive.v
Begin: 45
End: 45
Content: LHS := RHS
LHS: Inductive Boolean : Type
RHS: yes : Boolean | no : Boolean.
SortKey: D

Label: e8s65324
Name: boolean_induction
Class: Definition
File: src/base/primitive.v
Begin: 49
End: 52
Content: LHS := RHS
LHS: Definition boolean_induction
+      : forall (F : Boolean -> Type),
+          F yes -> F no -> forall (x : Boolean), F x
RHS: Boolean_rect.
SortKey: A

Label: x6u83qds
Name: Natural
Class: Inductive
File: src/base/primitive.v
Begin: 60
End: 61
Content: LHS := RHS
LHS: Inductive Natural : Type
RHS: zero : Natural | successor : Natural -> Natural.
SortKey: D

Label: mblpgwu0
Name: natural_induction
Class: Definition
File: src/base/primitive.v
Begin: 65
End: 70
Content: LHS := RHS
LHS: Definition natural_induction
+      : forall (F : Natural -> Type),
+          F zero
+            -> (forall (n : Natural), F n -> F (successor n))
+                -> forall (n : Natural), F n
RHS: Natural_rect.
SortKey: A

Label: whnabw73
Name: Equal
Class: Inductive
File: src/base/primitive.v
Begin: 78
End: 82
Content: LHS := RHS
LHS: Inductive Equal (X : Type) (x : X) : X -> Type
RHS: reflexive : Equal X x x.
+
+    Arguments Equal {X} x  _.
+    Arguments reflexive {X} x.
SortKey: D

Label: xxyabzuf
Name: equal_induction
Class: Definition
File: src/base/primitive.v
Begin: 86
End: 93
Content: LHS := RHS
LHS: Definition equal_induction
+      : forall (X : Type)
+               (x : X)
+               (F : forall (y : X), Equal x y -> Type),
+          F x (reflexive x) -> forall (y : X) (p : Equal x y), F y p
RHS: Equal_rect.
+
+    Arguments equal_induction {X} x F _ y p.
SortKey: A

Label: agn2f6jd
Name: _Sigma
Class: Record
File: src/base/primitive.v
Begin: 101
End: 107
Content: LHS := RHS
LHS: Record _Sigma (X : Type) (F : X -> Type) : Type
RHS: sigma {sigma1 : X; sigma2 : F sigma1}.
+
+    Arguments _Sigma {X} F.
+    Arguments sigma {X} F _ _.
+    Arguments sigma1 {X F} _.
+    Arguments sigma2 {X F} _.
SortKey: G

Label: 497e8me5
Name: "'Sigma' x .. y , P"
Class: Notation
File: src/base/primitive.v
Begin: 111
End: 113
Content: LHS := RHS
LHS: Notation "'Sigma' x .. y , P"
RHS: (_Sigma (fun x => .. (_Sigma (fun y => P)) ..))
+           (at level 200, x binder, y binder, right associativity).
SortKey: J

Label: 909vtogz
Name: NA
Class: Vernacular
File: src/base/same.v
Begin: 8
End: 9
Content: Require Import ufcoq.base.primitive.
+        Require Import ufcoq.base.construct.
LHS: NA
RHS: NA
SortKey: T

Label: ryjyw5yo
Name: _function_eta_conversion
Class: Example
File: src/base/same.v
Begin: 17
End: 21
Content: LHS := RHS
LHS: Example _function_eta_conversion
+      : forall (X : Type) (F : X -> Type) (f : forall (x : X), F x),
+          Equal f (fun (x : X) => f x)
RHS: fun (X : Type) (F : X -> Type) (f : forall (x : X), F x)
+          => reflexive f.
SortKey: Z

Label: r3y1kpvr
Name: _function_compose_associative
Class: Example
File: src/base/same.v
Begin: 25
End: 42
Content: LHS := RHS
LHS: Example _function_compose_associative
+      : forall (W : Type)
+               (X : Type)
+               (Y : Type)
+               (G : Y -> Type)
+               (g : forall (y : Y), G y)
+               (f : X -> Y)
+               (e : W -> X),
+          Equal (function_compose (function_compose g f) e)
+                (function_compose g (function_compose f e))
RHS: fun (W : Type)
+             (X : Type)
+             (Y : Type)
+             (G : Y -> Type)
+             (g : forall (y : Y), G y)
+             (f : X -> Y)
+             (e : W -> X)
+           => reflexive (function_compose (function_compose g f) e).
SortKey: Z

Label: hso05la4
Name: _function_compose_left_unit
Class: Example
File: src/base/same.v
Begin: 46
End: 50
Content: LHS := RHS
LHS: Example _function_compose_left_unit
+      : forall (X Y : Type) (f : X -> Y),
+          Equal f (function_compose (@identity_function Y) f)
RHS: fun (X Y : Type) (f : X -> Y)
+           => reflexive f.
SortKey: Z

Label: ey5cl868
Name: _function_compose_right_unit
Class: Example
File: src/base/same.v
Begin: 54
End: 62
Content: LHS := RHS
LHS: Example _function_compose_right_unit
+      : forall (X : Type)
+               (G : X -> Type)
+               (g : forall (x : X), G x),
+          Equal g (function_compose  g (@identity_function X))
RHS: fun (X : Type)
+             (G : X -> Type)
+             (g : forall (x : X), G x)
+           => reflexive g.
SortKey: Z

Label: tuh9sgix
Name: _true_induction_only
Class: Example
File: src/base/same.v
Begin: 70
End: 74
Content: LHS := RHS
LHS: Example _true_induction_only
+      : forall (F : True -> Type) (x : F only),
+          Equal x (true_induction F x only)
RHS: fun (F : True -> Type) (x : F only)
+           => reflexive x.
SortKey: Z

Label: iww5ck0g
Name: _true_recursion_only
Class: Example
File: src/base/same.v
Begin: 78
End: 80
Content: LHS := RHS
LHS: Example _true_recursion_only
+      : forall (X : Type) (x : X), Equal x (true_recursion x only)
RHS: fun (X : Type) (x : X) => reflexive x.
SortKey: Z

Label: qgyqpcz3
Name: _to_true_only
Class: Example
File: src/base/same.v
Begin: 84
End: 86
Content: LHS := RHS
LHS: Example _to_true_only
+      : forall (X : Type) (x : X), Equal only (to_true x)
RHS: fun (X : Type) (x : X) => reflexive only.
SortKey: Z

Label: ogo7jox4
Name: _boolean_induction_yes
Class: Example
File: src/base/same.v
Begin: 94
End: 97
Content: LHS := RHS
LHS: Example _boolean_induction_yes
+      : forall (F : Boolean -> Type) (y : F yes) (n : F no),
+          Equal y (boolean_induction F y n yes)
RHS: fun (F : Boolean -> Type) (y : F yes) (n : F no) => reflexive y.
SortKey: Z

Label: 6ly41ngr
Name: _boolean_induction_no
Class: Example
File: src/base/same.v
Begin: 101
End: 104
Content: LHS := RHS
LHS: Example _boolean_induction_no
+      : forall (F : Boolean -> Type) (y : F yes) (n : F no),
+          Equal n (boolean_induction F y n no)
RHS: fun (F : Boolean -> Type) (y : F yes) (n : F no) => reflexive n.
SortKey: Z

Label: 2wynnkw2
Name: _boolean_recursion_yes
Class: Example
File: src/base/same.v
Begin: 108
End: 110
Content: LHS := RHS
LHS: Example _boolean_recursion_yes
+      : forall (X : Type) (y n : X), Equal y (boolean_recursion y n yes)
RHS: fun (X : Type) (y n : X) => reflexive y.
SortKey: Z

Label: 4cga60mp
Name: _boolean_recursion_no
Class: Example
File: src/base/same.v
Begin: 114
End: 116
Content: LHS := RHS
LHS: Example _boolean_recursion_no
+      : forall (X : Type) (y n : X), Equal n (boolean_recursion y n no)
RHS: fun (X : Type) (y n : X) => reflexive n.
SortKey: Z

Label: p33ig2te
Name: _natural_induction_zero
Class: Example
File: src/base/same.v
Begin: 124
End: 132
Content: LHS := RHS
LHS: Example _natural_induction_zero
+      : forall (F : Natural -> Type)
+               (z : F zero)
+               (s : forall (n : Natural), F n -> F (successor n)),
+          Equal z (natural_induction F z s zero)
RHS: fun (F : Natural -> Type)
+             (z : F zero)
+             (s : forall (n : Natural), F n -> F (successor n))
+           => reflexive z.
SortKey: Z

Label: ojb7dh9z
Name: _natural_induction_successor
Class: Example
File: src/base/same.v
Begin: 136
End: 147
Content: LHS := RHS
LHS: Example _natural_induction_successor
+      : forall (F : Natural -> Type)
+               (z : F zero)
+               (s : forall (n : Natural), F n -> F (successor n))
+               (n : Natural),
+          Equal (s n (natural_induction F z s n))
+                (natural_induction F z s (successor n))
RHS: fun (F : Natural -> Type)
+             (z : F zero)
+             (s : forall (n : Natural), F n -> F (successor n))
+             (n : Natural)
+           => reflexive (s n (natural_induction F z s n)).
SortKey: Z

Label: rzfhv79d
Name: _natural_recursion_zero
Class: Example
File: src/base/same.v
Begin: 151
End: 155
Content: LHS := RHS
LHS: Example _natural_recursion_zero
+      : forall (X : Type) (z : X) (s : Natural -> X -> X),
+          Equal z (natural_recursion z s zero)
RHS: fun (X : Type) (z : X) (s : Natural -> X -> X)
+           => reflexive z.
SortKey: Z

Label: hrrncvpb
Name: _natural_recursion_successor
Class: Example
File: src/base/same.v
Begin: 159
End: 164
Content: LHS := RHS
LHS: Example _natural_recursion_successor
+      : forall (X : Type) (z : X) (s : Natural -> X -> X) (n : Natural),
+          Equal (s n (natural_recursion z s n))
+                (natural_recursion z s (successor n))
RHS: fun (X : Type) (z : X) (s : Natural -> X -> X) (n : Natural)
+         => reflexive (s n (natural_recursion z s n)).
SortKey: Z

Label: upakg9n0
Name: _natural_recursion_simple_zero
Class: Example
File: src/base/same.v
Begin: 168
End: 172
Content: LHS := RHS
LHS: Example _natural_recursion_simple_zero
+      : forall (X : Type) (z : X) (s : X -> X),
+          Equal z (natural_recursion_simple z s zero)
RHS: fun (X : Type) (z : X) (s : X -> X)
+           => reflexive z.
SortKey: Z

Label: tsfievor
Name: _natural_recursion_simple_successor
Class: Example
File: src/base/same.v
Begin: 176
End: 181
Content: LHS := RHS
LHS: Example _natural_recursion_simple_successor
+      : forall (X : Type) (z : X) (s : X -> X) (n : Natural),
+          Equal (s (natural_recursion_simple z s n))
+                (natural_recursion_simple z s (successor n))
RHS: fun (X : Type) (z : X) (s : X -> X) (n : Natural)
+           => reflexive (s (natural_recursion_simple z s n)).
SortKey: Z

Label: fznk9p3u
Name: _equal_induction_reflexive
Class: Example
File: src/base/same.v
Begin: 189
End: 199
Content: LHS := RHS
LHS: Example _equal_induction_reflexive
+      : forall (X : Type)
+               (x : X)
+               (F : forall (y : X), Equal x y -> Type)
+               (e : F x (reflexive x)),
+          Equal e (equal_induction x F e x (reflexive x))
RHS: fun (X : Type)
+             (x : X)
+             (F : forall (y : X), Equal x y -> Type)
+             (e : F x (reflexive x))
+           => reflexive e.
SortKey: Z

Label: obnor2k3
Name: _transport_reflexive
Class: Example
File: src/base/same.v
Begin: 203
End: 207
Content: LHS := RHS
LHS: Example _transport_reflexive
+      : forall (X : Type) (F : X -> Type) (x y : X),
+          Equal (@identity_function (F x)) (transport F (reflexive x))
RHS: fun (X : Type) (F : X -> Type) (x y : X)
+           => reflexive (@identity_function (F x)).
SortKey: Z

Label: iqo3w2uh
Name: _transport_inverse_reflexive
Class: Example
File: src/base/same.v
Begin: 211
End: 216
Content: LHS := RHS
LHS: Example _transport_inverse_reflexive
+      : forall (X : Type) (F : X -> Type) (x y : X),
+          Equal (@identity_function (F x))
+                (transport_inverse F (reflexive x))
RHS: fun (X : Type) (F : X -> Type) (x y : X)
+           => reflexive (@identity_function (F x)).
SortKey: Z

Label: qts05vtg
Name: _sigma_type_eta_conversion
Class: Example
File: src/base/same.v
Begin: 224
End: 228
Content: LHS := RHS
LHS: Example _sigma_type_eta_conversion
+      : forall (X : Type) (F : X -> Type) (t : Sigma (x : X), F x),
+          Equal t (sigma F (sigma1 t) (sigma2 t))
RHS: fun (X : Type) (F : X -> Type) (t : Sigma (x : X), F x)
+           => reflexive t.
SortKey: Z

Label: mrl11i2o
Name: _sigma_curry_uncurry
Class: Example
File: src/base/same.v
Begin: 232
End: 242
Content: LHS := RHS
LHS: Example _sigma_curry_uncurry
+      : forall (X : Type)
+               (F : X -> Type)
+               (G : (Sigma (x : X), F x) -> Type)
+               (f : forall (x : X) (y : F x), G (sigma F x y)),
+          Equal f (sigma_curry (sigma_uncurry f))
RHS: fun (X : Type)
+             (F : X -> Type)
+             (G : (Sigma (x : X), F x) -> Type)
+             (f : forall (x : X) (y : F x), G (sigma F x y))
+           => reflexive f.
SortKey: Z

Label: 4zlly4cd
Name: _sigma_uncurry_curry
Class: Example
File: src/base/same.v
Begin: 246
End: 256
Content: LHS := RHS
LHS: Example _sigma_uncurry_curry
+      : forall (X : Type)
+               (F : X -> Type)
+               (G : (Sigma (x : X), F x) -> Type)
+               (g : forall (t : Sigma (x : X), F x), G t),
+          Equal g (sigma_uncurry (sigma_curry g))
RHS: fun (X : Type)
+             (F : X -> Type)
+             (G : (Sigma (x : X), F x) -> Type)
+             (g : forall (t : Sigma (x : X), F x), G t)
+           => reflexive g.
SortKey: Z

Label: wruha80w
Name: _product_eta_conversion
Class: Example
File: src/base/same.v
Begin: 264
End: 268
Content: LHS := RHS
LHS: Example _product_eta_conversion
+      : forall (X Y : Type) (t : Product X Y),
+          Equal t (pair (first t) (second t))
RHS: fun (X Y : Type) (t : Product X Y)
+           => reflexive t.
SortKey: Z

Label: h1vgtr2g
Name: _curry_uncurry
Class: Example
File: src/base/same.v
Begin: 272
End: 280
Content: LHS := RHS
LHS: Example _curry_uncurry
+      : forall (X Y : Type)
+               (F : Product X Y -> Type)
+               (f : forall (x : X) (y : Y), F (pair x y)),
+            Equal f (curry (uncurry f))
RHS: fun (X Y : Type)
+             (F : Product X Y -> Type)
+             (f : forall (x : X) (y : Y), F (pair x y))
+           => reflexive f.
SortKey: Z

Label: u70g12vv
Name: _uncurry_curry
Class: Example
File: src/base/same.v
Begin: 284
End: 292
Content: LHS := RHS
LHS: Example _uncurry_curry
+      : forall (X Y : Type)
+               (F : Product X Y -> Type)
+               (g : forall (t : Product X Y), F t),
+          Equal g (uncurry (curry g))
RHS: fun (X Y : Type)
+             (F : Product X Y -> Type)
+             (g : forall (t : Product X Y), F t)
+           => reflexive g.
SortKey: Z

Label: rdugvrpr
Name: _pair_function_first
Class: Example
File: src/base/same.v
Begin: 296
End: 310
Content: LHS := RHS
LHS: Example _pair_function_first
+      : forall (T : Type)
+               (F : T -> Type)
+               (G : T -> Type)
+               (f : forall (t : T), F t)
+               (g : forall (t : T), G t)
+               (t : T),
+          Equal (f t) (first (pair_function f g t))
RHS: fun (T : Type)
+             (F : T -> Type)
+             (G : T -> Type)
+             (f : forall   (t : T), F t)
+             (g : forall (t : T), G t)
+             (t : T)
+           => reflexive (f t).
SortKey: Z

Label: z30hsvte
Name: _pair_function_second
Class: Example
File: src/base/same.v
Begin: 314
End: 328
Content: LHS := RHS
LHS: Example _pair_function_second
+      : forall (T : Type)
+               (F : T -> Type)
+               (G : T -> Type)
+               (f : forall (t : T), F t)
+               (g : forall (t : T), G t)
+               (t : T),
+          Equal (g t) (second (pair_function f g t))
RHS: fun (T : Type)
+             (F : T -> Type)
+             (G : T -> Type)
+             (f : forall   (t : T), F t)
+             (g : forall (t : T), G t)
+             (t : T)
+           => reflexive (g t).
SortKey: Z

Label: sh7mqmkt
Name: _product_map_first
Class: Example
File: src/base/same.v
Begin: 332
End: 341
Content: LHS := RHS
LHS: Example _product_map_first
+      : forall (X Y X' Y' : Type)
+               (f : X -> X')
+               (g : Y -> Y'),
+          Equal (function_compose f first)
+                (function_compose first (product_map f g))
RHS: fun (X Y X' Y' : Type)
+             (f : X -> X')
+             (g : Y -> Y')
+           => reflexive (function_compose f first).
SortKey: Z

Label: 2cjp777x
Name: _product_map_second
Class: Example
File: src/base/same.v
Begin: 345
End: 354
Content: LHS := RHS
LHS: Example _product_map_second
+      : forall (X Y X' Y' : Type)
+               (f : X -> X')
+               (g : Y -> Y'),
+          Equal (function_compose g second)
+                (function_compose second (product_map f g))
RHS: fun (X Y X' Y' : Type)
+             (f : X -> X')
+             (g : Y -> Y')
+           => reflexive (function_compose g second).
SortKey: Z

Label: hut1r4st
Name: _sum_induction_left
Class: Example
File: src/base/same.v
Begin: 362
End: 372
Content: LHS := RHS
LHS: Example _sum_induction_left
+      : forall (X Y : Type)
+               (F : Sum X Y -> Type)
+               (f : forall (x : X), F (left x))
+               (g : forall (y : Y), F (right y)),
+          Equal f (function_compose (sum_induction F f g) left)
RHS: fun (X Y : Type)
+             (F : Sum X Y -> Type)
+             (f : forall (x : X), F (left x))
+             (g : forall (y : Y), F (right y))
+           => reflexive f.
SortKey: Z

Label: w7zh5r1a
Name: _sum_induction_right
Class: Example
File: src/base/same.v
Begin: 376
End: 386
Content: LHS := RHS
LHS: Example _sum_induction_right
+      : forall (X Y : Type)
+               (F : Sum X Y -> Type)
+               (f : forall (x : X), F (left x))
+               (g : forall (y : Y), F (right y)),
+          Equal g (function_compose (sum_induction F f g) right)
RHS: fun (X Y : Type)
+             (F : Sum X Y -> Type)
+             (f : forall (x : X), F (left x))
+             (g : forall (y : Y), F (right y))
+           => reflexive g.
SortKey: Z

Label: jwfgf3zw
Name: _sum_recursion_left
Class: Example
File: src/base/same.v
Begin: 390
End: 398
Content: LHS := RHS
LHS: Example _sum_recursion_left
+      : forall (X Y Z : Type)
+               (f : X -> Z)
+               (g : Y -> Z),
+          Equal f (function_compose (sum_recursion f g) left)
RHS: fun (X Y Z : Type)
+             (f : X -> Z)
+             (g : Y -> Z)
+           => reflexive f.
SortKey: Z

Label: ll3xza2h
Name: _sum_recursion_right
Class: Example
File: src/base/same.v
Begin: 402
End: 410
Content: LHS := RHS
LHS: Example _sum_recursion_right
+      : forall (X Y Z : Type)
+               (f : X -> Z)
+               (g : Y -> Z),
+          Equal g (function_compose (sum_recursion f g) right)
RHS: fun (X Y Z : Type)
+             (f : X -> Z)
+             (g : Y -> Z)
+           => reflexive g.
SortKey: Z

Label: eb0iol83
Name: _sum_map_left
Class: Example
File: src/base/same.v
Begin: 414
End: 423
Content: LHS := RHS
LHS: Example _sum_map_left
+      : forall (X Y X' Y' : Type)
+               (f : X -> X')
+               (g : Y -> Y'),
+          Equal (function_compose left f)
+                (function_compose (sum_map f g) left)
RHS: fun (X Y X' Y' : Type)
+             (f : X -> X')
+             (g : Y -> Y')
+           => reflexive (function_compose left f).
SortKey: Z

Label: minkb801
Name: _sum_map_right
Class: Example
File: src/base/same.v
Begin: 427
End: 436
Content: LHS := RHS
LHS: Example _sum_map_right
+      : forall (X Y X' Y' : Type)
+               (f : X -> X')
+               (g : Y -> Y'),
+          Equal (function_compose right g)
+                (function_compose (sum_map f g) right)
RHS: fun (X Y X' Y' : Type)
+             (f : X -> X')
+             (g : Y -> Y')
+           => reflexive (function_compose right g).
SortKey: Z

Label: e82fgb1k
Name: NA
Class: Vernacular
File: src/base/equal.v
Begin: 8
End: 9
Content: Require Import ufcoq.base.primitive.
+        Require Import ufcoq.base.construct.
LHS: NA
RHS: NA
SortKey: T

Label: ybsrqsg4
Name: equal_compose
Class: Definition
File: src/base/equal.v
Begin: 17
End: 24
Content: LHS := RHS
LHS: Definition equal_compose
+      : forall (X : Type) (x y z : X), Equal x y -> Equal y z -> Equal x z
RHS: fun (X : Type)
+             (x y z : X)
+           => let F : X -> Type := fun (a : X) => Equal a z
+              in transport_inverse F.
+
+    Arguments equal_compose {X x y z} _ _.
SortKey: A

Label: ky5unwbq
Name: _equal_left_unit
Class: Example
File: src/base/equal.v
Begin: 28
End: 31
Content: LHS := RHS
LHS: Example _equal_left_unit
+      : forall (X : Type) (x y : X) (p : Equal x y),
+          Equal p (equal_compose (reflexive x) p)
RHS: fun (X : Type) (x y : X) (p : Equal x y) => reflexive p.
SortKey: Z

Label: afizq40q
Name: equal_right_unit
Class: Definition
File: src/base/equal.v
Begin: 35
End: 49
Content: LHS := RHS
LHS: Definition equal_right_unit
+      : forall (X : Type) (x y : X) (p : Equal x y),
+          Equal p (equal_compose p (reflexive y))
RHS: fun (X : Type) (x : X)
+           =>
+             let
+               F : forall (a : X), Equal x a -> Type
+                 := fun (a : X) (e : Equal x a)
+                      => Equal e (equal_compose e (reflexive a))
+             in let
+               base : F x (reflexive x) := reflexive (reflexive x)
+             in
+               equal_induction x F base.
+
+    Arguments equal_right_unit {X x y} p.
SortKey: A

Label: qj3cqa2b
Name: equal_associative
Class: Definition
File: src/base/equal.v
Begin: 53
End: 83
Content: LHS := RHS
LHS: Definition equal_associative
+      : forall (X : Type)
+               (w x y z : X)
+               (p : Equal w x)
+               (q : Equal x y)
+               (r : Equal y z),
+          Equal (equal_compose (equal_compose p q) r)
+                (equal_compose p (equal_compose q r))
RHS: fun (X : Type)
+             (w x y z : X)
+             (p : Equal w x)
+             (q : Equal x y)
+             (r : Equal y z)
+           =>
+             let
+               F : forall (a : X), Equal w a -> Type
+                 := fun (a : X) (i : Equal w a)
+                      => forall (j : Equal a y),
+                           Equal (equal_compose (equal_compose i j) r)
+                                 (equal_compose i (equal_compose j r))
+             in let
+               base : F w (reflexive w)
+                 := fun (j : Equal w y)
+                      => reflexive (equal_compose j r)
+             in let
+               inductive : forall (a : X) (i : Equal w a), F a i
+                 := equal_induction w F base
+             in
+               inductive x p q.
+
+    Arguments equal_associative {X w x y z} p q r.
SortKey: A

Label: smege15s
Name: equal_compose_left_equal
Class: Definition
File: src/base/equal.v
Begin: 87
End: 110
Content: LHS := RHS
LHS: Definition equal_compose_left_equal
+      : forall (X : Type) (x y : X) (p p' : Equal x y),
+          Equal p p'
+            -> forall (z : X) (q : Equal y z),
+                 Equal (equal_compose p q) (equal_compose p' q)
RHS: fun (X : Type)
+             (x y : X)
+             (p p' : Equal x y)
+             (u : Equal p p')
+             (z : X)
+             (q : Equal y z)
+           =>
+             let
+               F : forall (i : Equal x y), Equal p i -> Type
+                 := fun (i  : Equal x y)
+                      => constant_function (Equal (equal_compose p q)
+                                                  (equal_compose i q))
+             in let
+               base : F p (reflexive p)
+                 := reflexive (equal_compose p q)
+             in
+               equal_induction p F base p' u.
+
+    Arguments equal_compose_left_equal {X x y p p'} _ {z} q.
SortKey: A

Label: g6ql88po
Name: equal_compose_right_equal
Class: Definition
File: src/base/equal.v
Begin: 114
End: 139
Content: LHS := RHS
LHS: Definition equal_compose_right_equal
+      : forall (X : Type)
+               (x y : X)
+               (p : Equal x y)
+               (z : X)
+               (q q' : Equal y z),
+          Equal q q' -> Equal (equal_compose p q) (equal_compose p q')
RHS: fun (X : Type)
+             (x y : X)
+             (p : Equal x y)
+             (z : X)
+             (q q' : Equal y z)
+             (v : Equal q q')
+           =>
+             let
+               F : forall (j : Equal y z), Equal q j -> Type
+                 := fun (j  : Equal y z)
+                      => constant_function (Equal (equal_compose p q)
+                                                  (equal_compose p j))
+             in let
+               base : F q (reflexive q)
+                 := reflexive (equal_compose p q)
+             in
+               equal_induction q F base q' v.
+
+    Arguments equal_compose_right_equal {X x y} p {z q q'} _.
SortKey: A

Label: npsmi0d4
Name: equal_compose_equal
Class: Definition
File: src/base/equal.v
Begin: 143
End: 166
Content: LHS := RHS
LHS: Definition equal_compose_equal
+      : forall (X : Type)
+               (x y z : X)
+               (p p' : Equal x y)
+               (q q' : Equal y z),
+          Equal p p' -> Equal q q'
+            -> Equal (equal_compose p q) (equal_compose p' q')
RHS: fun (X : Type)
+             (x y z : X)
+             (p p' : Equal x y)
+             (q q' : Equal y z)
+             (u : Equal p p')
+             (v : Equal q q')
+           =>
+             let
+               e : Equal (equal_compose p q) (equal_compose p' q)
+                 := equal_compose_left_equal u q
+             in let
+               f : Equal (equal_compose p' q) (equal_compose p' q')
+                 := equal_compose_right_equal p' v
+             in
+               equal_compose e f.
+
+    Arguments equal_compose_equal {X x y z p p' q q'} _ _.
SortKey: A

Label: 37wczvy0
Name: equal_inverse
Class: Definition
File: src/base/equal.v
Begin: 174
End: 186
Content: LHS := RHS
LHS: Definition equal_inverse
+      : forall (X : Type) (x y : X), Equal x y -> Equal y x
RHS: fun (X : Type) (x : X)
+           =>
+             let
+               F : forall (y : X), Equal x y -> Type
+                 := fun (y : X) => constant_function (Equal y x)
+             in let
+               base : F x (reflexive x) := reflexive x
+             in
+               equal_induction x F base.
+
+    Arguments equal_inverse {X x y} _.
SortKey: A

Label: fehutg63
Name: _equal_inverse_reflexive
Class: Example
File: src/base/equal.v
Begin: 190
End: 193
Content: LHS := RHS
LHS: Example _equal_inverse_reflexive
+      : forall (X : Type) (x : X),
+          Equal (reflexive x) (equal_inverse (reflexive x))
RHS: fun (X : Type) (x : X) => reflexive (reflexive x).
SortKey: Z

Label: czd5dw60
Name: equal_left_inverse
Class: Definition
File: src/base/equal.v
Begin: 197
End: 212
Content: LHS := RHS
LHS: Definition equal_left_inverse
+      : forall (X : Type) (x y : X) (p : Equal x y),
+          Equal (reflexive y) (equal_compose (equal_inverse p) p)
RHS: fun (X : Type) (x : X)
+           =>
+             let
+               F : forall (y : X), Equal x y -> Type
+                 := fun (y : X) (p : Equal x y)
+                      => Equal (reflexive y)
+                               (equal_compose (equal_inverse p) p)
+             in let
+               base : F x (reflexive x) := reflexive (reflexive x)
+             in
+               equal_induction x F base.
+
+    Arguments equal_left_inverse {X x y} p.
SortKey: A

Label: eay5nxer
Name: equal_right_inverse
Class: Definition
File: src/base/equal.v
Begin: 216
End: 231
Content: LHS := RHS
LHS: Definition equal_right_inverse
+      : forall (X : Type) (x y : X) (p : Equal x y),
+          Equal (reflexive x) (equal_compose p (equal_inverse p))
RHS: fun (X : Type) (x : X)
+           =>
+             let
+               F : forall (y : X), Equal x y -> Type
+                 := fun (y : X) (p : Equal x y)
+                      => Equal (reflexive x)
+                               (equal_compose p (equal_inverse p))
+             in let
+               base : F x (reflexive x) := reflexive (reflexive x)
+             in
+               equal_induction x F base.
+
+    Arguments equal_right_inverse {X x y} p.
SortKey: A

Label: lxgjdap3
Name: equal_map
Class: Definition
File: src/base/equal.v
Begin: 239
End: 252
Content: LHS := RHS
LHS: Definition equal_map
+      : forall (X Y : Type) (f : X -> Y) (x x' : X),
+          Equal x x' -> Equal (f x) (f x')
RHS: fun (X Y : Type) (f : X -> Y) (x : X)
+           =>
+             let
+               F : forall (x' : X), Equal x x' -> Type
+                 := fun (x' : X) => constant_function (Equal (f x) (f x'))
+             in let
+               base : F x (reflexive x) := reflexive (f x)
+             in
+               equal_induction x F base.
+
+    Arguments equal_map {X Y} f {x x'} _.
SortKey: A

Label: udxkkzqg
Name: _equal_map_unital
Class: Example
File: src/base/equal.v
Begin: 256
End: 260
Content: LHS := RHS
LHS: Example _equal_map_unital
+      : forall (X Y : Type) (f : X -> Y) (x : X),
+          Equal (reflexive (f x)) (equal_map f (reflexive x))
RHS: fun (X Y : Type) (f : X -> Y) (x : X)
+           => reflexive (reflexive (f x)).
SortKey: Z

Label: bul2i30n
Name: equal_map_multiplicative
Class: Definition
File: src/base/equal.v
Begin: 264
End: 287
Content: LHS := RHS
LHS: Definition equal_map_multiplicative
+      : forall (X Y : Type)
+               (f : X -> Y)
+               (x1 x2 x3 : X)
+               (p : Equal x1 x2)
+               (q : Equal x2 x3),
+          Equal (equal_map f (equal_compose p q))
+                (equal_compose (equal_map f p) (equal_map f q))
RHS: fun (X Y : Type) (f : X -> Y) (x1 x2 x3 : X)
+           =>
+             let
+               F : forall (a : X), Equal x1 a -> Type
+                 := fun (a : X) (p : Equal x1 a)
+                      => forall (q : Equal a x3),
+                           Equal (equal_map f (equal_compose p q))
+                                 (equal_compose (equal_map f p) (equal_map f q))
+             in let
+               base : F x1 (reflexive x1)
+                 := fun (q : Equal x1 x3)
+                      => reflexive (equal_map f q)
+             in
+               equal_induction x1 F base x2.
+
+    Arguments equal_map_multiplicative {X Y} f {x1 x2 x3} p q.
SortKey: A

Label: 5e7zp56e
Name: equal_map_inverse
Class: Definition
File: src/base/equal.v
Begin: 291
End: 307
Content: LHS := RHS
LHS: Definition equal_map_inverse
+      : forall (X Y : Type) (f : X -> Y) (x x' : X) (p : Equal x x'),
+          Equal (equal_map f (equal_inverse p))
+                (equal_inverse (equal_map f p))
RHS: fun (X Y : Type) (f : X -> Y) (x : X)
+           =>
+             let
+               F : forall (x' : X), Equal x x' -> Type
+                 := fun (x' : X) (p : Equal x x')
+                      => Equal (equal_map f (equal_inverse p))
+                               (equal_inverse (equal_map f p))
+             in let
+               base : F x (reflexive x) := reflexive (reflexive (f x))
+             in
+               equal_induction x F base.
+
+    Arguments equal_map_inverse {X Y} f {x x'} p.
SortKey: A

Label: omtjvrai
Name: equal_left_cancel
Class: Definition
File: src/base/equal.v
Begin: 315
End: 336
Content: LHS := RHS
LHS: Definition equal_left_cancel
+      : forall (X : Type) (x y z : X) (p : Equal x y) (q q' : Equal y z),
+          Equal (equal_compose p q) (equal_compose p q') -> Equal q q'
RHS: fun (X : Type) (x y z : X) (p : Equal x y) (q q' : Equal y z)
+           =>
+             let
+               F : forall (a : X), Equal x a -> Type
+                 := fun (a : X) (i : Equal x a)
+                      => forall (j j' :  Equal a z),
+                           Equal (equal_compose i j) (equal_compose i j')
+                             -> Equal j j'
+             in let
+               base : F x (reflexive x)
+                 := fun (j j' : Equal x z)
+                      => @identity_function (Equal j j')
+             in let
+               inductive : forall (a : X) (i : Equal x a), F a i
+                 := equal_induction x F base
+             in
+               inductive y p q q'.
+
+    Arguments equal_left_cancel {X x y z} p q q' _.
SortKey: A

Label: 865g4mt7
Name: equal_left_remove
Class: Definition
File: src/base/equal.v
Begin: 340
End: 365
Content: LHS := RHS
LHS: Definition equal_left_remove
+      : forall (X : Type)
+               (x y : X)
+               (p p' : Equal x y),
+          Equal p p'
+            -> forall (z : X) (q q' : Equal y z),
+                 Equal (equal_compose p q) (equal_compose p' q')
+                   -> Equal q q'
RHS: fun (X : Type)
+             (x y : X)
+             (p p' : Equal x y)
+             (u : Equal p p')
+             (z : X)
+             (q q' : Equal y z)
+             (e : Equal (equal_compose p q) (equal_compose p' q'))
+           =>
+             let
+               e1 : Equal (equal_compose p q') (equal_compose p' q')
+                  := equal_compose_left_equal u q'
+             in let
+               e2 : Equal (equal_compose p q) (equal_compose p q')
+                  := equal_compose e (equal_inverse e1)
+             in
+               equal_left_cancel p q q' e2.
+
+    Arguments equal_left_remove {X x y p p'} _ {z} q q' _.
SortKey: A

Label: 8gh9140h
Name: equal_right_cancel
Class: Definition
File: src/base/equal.v
Begin: 369
End: 400
Content: LHS := RHS
LHS: Definition equal_right_cancel
+      : forall (X : Type) (x y z : X) (p p' : Equal x y) (q : Equal y z),
+          Equal (equal_compose p q) (equal_compose p' q) -> Equal p p'
RHS: fun (X : Type) (x y z : X) (p p' : Equal x y) (q : Equal y z)
+           =>
+             let
+               F : forall (a : X), Equal y a -> Type
+                 := fun (a : X) (j : Equal y a)
+                      => forall (i i' :  Equal x y),
+                           Equal (equal_compose i j) (equal_compose i' j)
+                             -> Equal i i'
+             in let
+               base : F y (reflexive y)
+                 := fun (i i' : Equal x y)
+                        (u : Equal (equal_compose i (reflexive y))
+                                   (equal_compose i' (reflexive y)))
+                      =>
+                        let
+                          e1 : Equal i (equal_compose i (reflexive y))
+                             := equal_right_unit i
+                        in let
+                          e2 : Equal (equal_compose i' (reflexive y)) i'
+                             := equal_inverse (equal_right_unit i')
+                        in
+                          equal_compose (equal_compose e1 u) e2
+             in let
+               inductive : forall (a : X) (j : Equal y a), F a j
+                 := equal_induction y F base
+             in
+               inductive z q p p'.
+
+    Arguments equal_right_cancel {X x y z} p p' q _.
SortKey: A

Label: sqhuo1hf
Name: equal_right_remove
Class: Definition
File: src/base/equal.v
Begin: 404
End: 430
Content: LHS := RHS
LHS: Definition equal_right_remove
+      : forall (X : Type)
+               (x y : X)
+               (p p' : Equal x y)
+               (z : X)
+               (q q' : Equal y z),
+          Equal q q'
+            -> Equal (equal_compose p q) (equal_compose p' q')
+              -> Equal p p'
RHS: fun (X : Type)
+             (x y : X)
+             (p p' : Equal x y)
+             (z : X)
+             (q q' : Equal y z)
+             (v : Equal q q')
+             (e : Equal (equal_compose p q) (equal_compose p' q'))
+           =>
+             let
+               e1 : Equal (equal_compose p' q) (equal_compose p' q')
+                  := equal_compose_right_equal p' v
+             in let
+               e2 : Equal (equal_compose p q) (equal_compose p' q)
+                  := equal_compose e (equal_inverse e1)
+             in
+               equal_right_cancel p p' q e2.
+
+    Arguments equal_right_remove {X x y} p p' {z} {q q'} _ _.
SortKey: A

Label: x71kqflr
Name: equal_left_unit_unique
Class: Definition
File: src/base/equal.v
Begin: 438
End: 444
Content: LHS := RHS
LHS: Definition equal_left_unit_unique
+      : forall (X : Type) (x y : X) (p : Equal x x) (q : Equal x y),
+          Equal q (equal_compose p q) -> Equal (reflexive x) p
RHS: fun (X : Type) (x y : X) (p : Equal x x) (q : Equal x y)
+           => equal_right_cancel (reflexive x) p q.
+
+    Arguments equal_left_unit_unique {X x y} p {q} _.
SortKey: A

Label: m1jqzny4
Name: equal_right_unit_unique
Class: Definition
File: src/base/equal.v
Begin: 448
End: 467
Content: LHS := RHS
LHS: Definition equal_right_unit_unique
+      : forall (X : Type) (x y : X) (p : Equal x y) (q : Equal y y),
+          Equal p (equal_compose p q) -> Equal (reflexive y) q
RHS: fun (X : Type)
+             (x y : X)
+             (p : Equal x y)
+             (q : Equal y y)
+             (u : Equal p (equal_compose p q))
+           =>
+             let
+               e : Equal p (equal_compose p (reflexive y))
+                 := equal_right_unit p
+             in let
+               f : Equal (equal_compose p (reflexive y))
+                         (equal_compose p q)
+                 := equal_compose (equal_inverse e) u
+             in
+               equal_left_cancel p (reflexive y) q f.
+
+    Arguments equal_right_unit_unique {X x y p} q _.
SortKey: A

### End of file
