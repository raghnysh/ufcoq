### Recutils database for fragments from files

## This file is automatically generated.  Do not edit it.

%rec: Fragment
%key: Label
%sort: SortKey Name File Begin
%doc: Fragments from files
+ Label: a unique identifier for the fragment
+ Name: the name of the main object of the fragment if applicable else NA
+ Class: the category of the main object of the fragment
+ File: the file containing the fragment
+ Begin: the number in the file of the first line of the fragment
+ End: the number in the file of the last line of the fragment
+ Content: the text of the fragment
+ LHS: the left hand side of the first := in Content if applicable else NA
+ RHS: the right hand side of the first := in Content if applicable else NA
+ SortKey: a string used for sorting the records

Label: zf4f204h
Name: NA
Class: Vernacular
File: src/base/construct.v
Begin: 8
End: 8
Content: Require Import ufcoq.base.primitive.
LHS: NA
RHS: NA
SortKey: T

Label: b5b085qn
Name: Kind
Class: Definition
File: src/base/construct.v
Begin: 16
End: 19
Content: Definition Kind : forall (X : Type), X -> Type\\n  := fun (X : Type) (x : X) => X.\\n\\nArguments Kind {X} _.
LHS: Definition Kind : forall (X : Type), X -> Type
RHS: fun (X : Type) (x : X) => X.\\n\\nArguments Kind {X} _.
SortKey: A

Label: yrbfo0qa
Name: FunctionDomain
Class: Definition
File: src/base/construct.v
Begin: 27
End: 31
Content: Definition FunctionDomain\\n  : forall (X : Type) (F : X -> Type), (forall (x : X), F x) -> Type\\n  := fun (X : Type) (F : X -> Type) (f : forall (x : X), F x) => X.\\n\\nArguments FunctionDomain {X} {F} _.
LHS: Definition FunctionDomain\\n  : forall (X : Type) (F : X -> Type), (forall (x : X), F x) -> Type
RHS: fun (X : Type) (F : X -> Type) (f : forall (x : X), F x) => X.\\n\\nArguments FunctionDomain {X} {F} _.
SortKey: A

Label: qolnxg6a
Name: FunctionCodomain
Class: Definition
File: src/base/construct.v
Begin: 35
End: 41
Content: Definition FunctionCodomain\\n  : forall (X : Type) (F : X -> Type),\\n      (forall (x : X), F x) -> X -> Type\\n  := fun (X : Type) (F : X -> Type)\\n       (f : forall (x : X), F x) (a : X) => F a.\\n\\nArguments FunctionCodomain {X} {F} _ _.
LHS: Definition FunctionCodomain\\n  : forall (X : Type) (F : X -> Type),\\n      (forall (x : X), F x) -> X -> Type
RHS: fun (X : Type) (F : X -> Type)\\n       (f : forall (x : X), F x) (a : X) => F a.\\n\\nArguments FunctionCodomain {X} {F} _ _.
SortKey: A

Label: jezpb6sa
Name: function_value
Class: Definition
File: src/base/construct.v
Begin: 45
End: 51
Content: Definition function_value\\n  : forall (X : Type) (F : X -> Type) (a : X),\\n      (forall (x : X), F x) -> F a\\n  := fun (X : Type) (F : X -> Type) (a : X)\\n       (f : forall (x : X), F x) => f a.\\n\\nArguments function_value {X} {F} a _.
LHS: Definition function_value\\n  : forall (X : Type) (F : X -> Type) (a : X),\\n      (forall (x : X), F x) -> F a
RHS: fun (X : Type) (F : X -> Type) (a : X)\\n       (f : forall (x : X), F x) => f a.\\n\\nArguments function_value {X} {F} a _.
SortKey: A

Label: u4wjel9o
Name: function_compose
Class: Definition
File: src/base/construct.v
Begin: 55
End: 68
Content: Definition function_compose\\n  : forall (X Y : Type)\\n           (G : Y -> Type)\\n           (g : forall (y : Y), G y)\\n           (f : X -> Y),\\n      forall (x : X), G (f x)\\n  := fun (X Y : Type)\\n         (G : Y -> Type)\\n         (g : forall (y : Y), G y)\\n         (f : X -> Y)\\n         (x : X)\\n       => g (f x).\\n\\nArguments function_compose {X Y G} g f _.
LHS: Definition function_compose\\n  : forall (X Y : Type)\\n           (G : Y -> Type)\\n           (g : forall (y : Y), G y)\\n           (f : X -> Y),\\n      forall (x : X), G (f x)
RHS: fun (X Y : Type)\\n         (G : Y -> Type)\\n         (g : forall (y : Y), G y)\\n         (f : X -> Y)\\n         (x : X)\\n       => g (f x).\\n\\nArguments function_compose {X Y G} g f _.
SortKey: A

Label: ct7rwcsm
Name: identity_function
Class: Definition
File: src/base/construct.v
Begin: 72
End: 75
Content: Definition identity_function : forall (X : Type), X -> X\\n  := fun (X : Type) (x : X) => x.\\n\\nArguments identity_function {X} _.
LHS: Definition identity_function : forall (X : Type), X -> X
RHS: fun (X : Type) (x : X) => x.\\n\\nArguments identity_function {X} _.
SortKey: A

Label: q4yy6ynm
Name: constant_function
Class: Definition
File: src/base/construct.v
Begin: 79
End: 82
Content: Definition constant_function : forall (X Y : Type), Y -> X -> Y\\n  := fun (X Y : Type) (y : Y) (_ : X) => y.\\n\\nArguments constant_function {X Y} _ _.
LHS: Definition constant_function : forall (X Y : Type), Y -> X -> Y
RHS: fun (X Y : Type) (y : Y) (_ : X) => y.\\n\\nArguments constant_function {X Y} _ _.
SortKey: A

Label: 867thqwu
Name: functions_equal_values_equal
Class: Definition
File: src/base/construct.v
Begin: 86
End: 107
Content: Definition functions_equal_values_equal\\n  : forall (X : Type)\\n           (F : X -> Type)\\n           (f g : forall (x : X), F x),\\n      Equal f g -> forall (x : X), Equal (f x) (g x)\\n  := fun (X : Type)\\n         (F : X -> Type)\\n         (f : forall (x : X), F x)\\n       =>\\n         let\\n           T : Type := forall (x : X), F x\\n         in let\\n           P : forall (t : T), Equal f t -> Type\\n             := fun (t : T)\\n                  => constant_function\\n                       (forall (x : X), Equal (f x) (t x))\\n         in let\\n           base : P f (reflexive f) := fun (x : X) => reflexive (f x)\\n         in\\n           equal_induction f P base.\\n\\nArguments functions_equal_values_equal {X F f g} _ x.
LHS: Definition functions_equal_values_equal\\n  : forall (X : Type)\\n           (F : X -> Type)\\n           (f g : forall (x : X), F x),\\n      Equal f g -> forall (x : X), Equal (f x) (g x)
RHS: fun (X : Type)\\n         (F : X -> Type)\\n         (f : forall (x : X), F x)\\n       =>\\n         let\\n           T : Type := forall (x : X), F x\\n         in let\\n           P : forall (t : T), Equal f t -> Type\\n             := fun (t : T)\\n                  => constant_function\\n                       (forall (x : X), Equal (f x) (t x))\\n         in let\\n           base : P f (reflexive f) := fun (x : X) => reflexive (f x)\\n         in\\n           equal_induction f P base.\\n\\nArguments functions_equal_values_equal {X F f g} _ x.
SortKey: A

Label: gcfsyi93
Name: false_recursion
Class: Definition
File: src/base/construct.v
Begin: 115
End: 117
Content: Definition false_recursion : forall (X : Type), False -> X\\n  := fun (X : Type)\\n       => false_induction (@constant_function False Type X).
LHS: Definition false_recursion : forall (X : Type), False -> X
RHS: fun (X : Type)\\n       => false_induction (@constant_function False Type X).
SortKey: A

Label: kad6krsx
Name: true_recursion
Class: Definition
File: src/base/construct.v
Begin: 121
End: 125
Content: Definition true_recursion : forall (X : Type), X -> True -> X\\n  := fun (X : Type)\\n       => true_induction (@constant_function True Type X).\\n\\nArguments true_recursion {X} _ _.
LHS: Definition true_recursion : forall (X : Type), X -> True -> X
RHS: fun (X : Type)\\n       => true_induction (@constant_function True Type X).\\n\\nArguments true_recursion {X} _ _.
SortKey: A

Label: cppabof7
Name: to_true
Class: Definition
File: src/base/construct.v
Begin: 129
End: 132
Content: Definition to_true : forall (X : Type), X -> True\\n  := fun (X : Type) => constant_function only.\\n\\nArguments to_true {X} _.
LHS: Definition to_true : forall (X : Type), X -> True
RHS: fun (X : Type) => constant_function only.\\n\\nArguments to_true {X} _.
SortKey: A

Label: tav7tpv0
Name: boolean_recursion
Class: Definition
File: src/base/construct.v
Begin: 136
End: 141
Content: Definition boolean_recursion\\n  : forall (X : Type), X -> X -> Boolean -> X\\n  := fun (X : Type)\\n       => boolean_induction (@constant_function Boolean Type X).\\n\\nArguments boolean_recursion {X} _ _ _.
LHS: Definition boolean_recursion\\n  : forall (X : Type), X -> X -> Boolean -> X
RHS: fun (X : Type)\\n       => boolean_induction (@constant_function Boolean Type X).\\n\\nArguments boolean_recursion {X} _ _ _.
SortKey: A

Label: 8m7c7dml
Name: natural_recursion
Class: Definition
File: src/base/construct.v
Begin: 145
End: 150
Content: Definition natural_recursion\\n  : forall (X : Type), X -> (Natural -> X -> X) -> Natural -> X\\n  := fun (X : Type) =>\\n      natural_induction (@constant_function Natural Type X).\\n\\nArguments natural_recursion {X} _ _ _.
LHS: Definition natural_recursion\\n  : forall (X : Type), X -> (Natural -> X -> X) -> Natural -> X
RHS: fun (X : Type) =>\\n      natural_induction (@constant_function Natural Type X).\\n\\nArguments natural_recursion {X} _ _ _.
SortKey: A

Label: yhafxlw0
Name: natural_recursion_simple
Class: Definition
File: src/base/construct.v
Begin: 154
End: 159
Content: Definition natural_recursion_simple\\n  : forall (X : Type), X -> (X -> X) -> Natural -> X\\n  := fun (X : Type) (x : X) (f : X -> X)\\n       => natural_recursion x (@constant_function Natural (X -> X) f).\\n\\nArguments natural_recursion_simple {X} _ _ _.
LHS: Definition natural_recursion_simple\\n  : forall (X : Type), X -> (X -> X) -> Natural -> X
RHS: fun (X : Type) (x : X) (f : X -> X)\\n       => natural_recursion x (@constant_function Natural (X -> X) f).\\n\\nArguments natural_recursion_simple {X} _ _ _.
SortKey: A

Label: szbmydj4
Name: transport
Class: Definition
File: src/base/construct.v
Begin: 163
End: 179
Content: Definition transport\\n  : forall (X : Type) (F : X -> Type) (x y : X),\\n      Equal x y -> F x -> F y\\n  := fun (X : Type)\\n         (F : X -> Type)\\n         (x : X)\\n       =>\\n         let\\n           G : forall (a : X), Equal x a -> Type\\n             := fun (a : X) => constant_function (F x -> F a)\\n         in let\\n           base : G x (reflexive x)\\n             := @identity_function (F x)\\n         in\\n           equal_induction x G base.\\n\\nArguments transport {X} F {x y} _ _.
LHS: Definition transport\\n  : forall (X : Type) (F : X -> Type) (x y : X),\\n      Equal x y -> F x -> F y
RHS: fun (X : Type)\\n         (F : X -> Type)\\n         (x : X)\\n       =>\\n         let\\n           G : forall (a : X), Equal x a -> Type\\n             := fun (a : X) => constant_function (F x -> F a)\\n         in let\\n           base : G x (reflexive x)\\n             := @identity_function (F x)\\n         in\\n           equal_induction x G base.\\n\\nArguments transport {X} F {x y} _ _.
SortKey: A

Label: xsfz3fch
Name: transport_inverse
Class: Definition
File: src/base/construct.v
Begin: 183
End: 199
Content: Definition transport_inverse\\n  : forall (X : Type) (F : X -> Type) (x y : X),\\n      Equal x y -> F y -> F x\\n  := fun (X : Type)\\n         (F : X -> Type)\\n         (x : X)\\n       =>\\n         let\\n           G : forall (a : X), Equal x a -> Type\\n             := fun (a : X) => constant_function (F a -> F x)\\n         in let\\n           base : G x (reflexive x)\\n             := @identity_function (F x)\\n         in\\n           equal_induction x G base.\\n\\nArguments transport_inverse {X} F {x y} _ _.
LHS: Definition transport_inverse\\n  : forall (X : Type) (F : X -> Type) (x y : X),\\n      Equal x y -> F y -> F x
RHS: fun (X : Type)\\n         (F : X -> Type)\\n         (x : X)\\n       =>\\n         let\\n           G : forall (a : X), Equal x a -> Type\\n             := fun (a : X) => constant_function (F a -> F x)\\n         in let\\n           base : G x (reflexive x)\\n             := @identity_function (F x)\\n         in\\n           equal_induction x G base.\\n\\nArguments transport_inverse {X} F {x y} _ _.
SortKey: A

Label: wlyu1bpv
Name: sigma_induction
Class: Definition
File: src/base/construct.v
Begin: 203
End: 216
Content: Definition sigma_induction\\n  : forall (X : Type)\\n           (F : X -> Type)\\n           (G : (Sigma (x : X), F x) -> Type),\\n      (forall (x : X) (y : F x), G (sigma F x y))\\n        -> (forall (t : Sigma (x : X), F x), G t)\\n  := fun (X : Type)\\n         (F : X -> Type)\\n         (G : (Sigma (x : X), F x) -> Type)\\n         (f : forall (x : X) (y : F x), G (sigma F x y))\\n         (t : Sigma (x : X), F x)\\n    => f (sigma1 t) (sigma2 t).\\n\\nArguments sigma_induction {X F G} _ _.
LHS: Definition sigma_induction\\n  : forall (X : Type)\\n           (F : X -> Type)\\n           (G : (Sigma (x : X), F x) -> Type),\\n      (forall (x : X) (y : F x), G (sigma F x y))\\n        -> (forall (t : Sigma (x : X), F x), G t)
RHS: fun (X : Type)\\n         (F : X -> Type)\\n         (G : (Sigma (x : X), F x) -> Type)\\n         (f : forall (x : X) (y : F x), G (sigma F x y))\\n         (t : Sigma (x : X), F x)\\n    => f (sigma1 t) (sigma2 t).\\n\\nArguments sigma_induction {X F G} _ _.
SortKey: A

Label: dq9dzz6c
Name: sigma_uncurry
Class: Definition
File: src/base/construct.v
Begin: 220
End: 228
Content: Definition sigma_uncurry\\n  : forall (X : Type)\\n           (F : X -> Type)\\n           (G : (Sigma (x : X), F x) -> Type),\\n      (forall (x : X) (y : F x), G (sigma F x y))\\n        -> forall (t : Sigma (x : X), F x), G t\\n  := @sigma_induction.\\n\\nArguments sigma_uncurry {X F G} _ _.
LHS: Definition sigma_uncurry\\n  : forall (X : Type)\\n           (F : X -> Type)\\n           (G : (Sigma (x : X), F x) -> Type),\\n      (forall (x : X) (y : F x), G (sigma F x y))\\n        -> forall (t : Sigma (x : X), F x), G t
RHS: @sigma_induction.\\n\\nArguments sigma_uncurry {X F G} _ _.
SortKey: A

Label: gewpttx0
Name: sigma_curry
Class: Definition
File: src/base/construct.v
Begin: 232
End: 246
Content: Definition sigma_curry\\n  : forall (X : Type)\\n           (F : X -> Type)\\n           (G : (Sigma (x : X), F x) -> Type),\\n      (forall (t : Sigma (x : X), F x), G t)\\n        -> forall (x : X) (y : F x), G (sigma F x y)\\n  := fun  (X : Type)\\n          (F : X -> Type)\\n          (G : (Sigma (x : X), F x) -> Type)\\n          (g : forall (t : Sigma (x : X), F x), G t)\\n          (x : X)\\n          (y : F x)\\n       => g (sigma F x y).\\n\\nArguments sigma_curry {X F G} _ _ _.
LHS: Definition sigma_curry\\n  : forall (X : Type)\\n           (F : X -> Type)\\n           (G : (Sigma (x : X), F x) -> Type),\\n      (forall (t : Sigma (x : X), F x), G t)\\n        -> forall (x : X) (y : F x), G (sigma F x y)
RHS: fun  (X : Type)\\n          (F : X -> Type)\\n          (G : (Sigma (x : X), F x) -> Type)\\n          (g : forall (t : Sigma (x : X), F x), G t)\\n          (x : X)\\n          (y : F x)\\n       => g (sigma F x y).\\n\\nArguments sigma_curry {X F G} _ _ _.
SortKey: A

Label: siygmnhf
Name: sigma_recursion
Class: Definition
File: src/base/construct.v
Begin: 250
End: 262
Content: Definition sigma_recursion\\n  : forall (X : Type)\\n           (F : X -> Type)\\n           (Y : Type),\\n      (forall (x : X), F x -> Y) -> (Sigma (x : X), F x) -> Y\\n  := fun (X : Type)\\n         (F : X -> Type)\\n         (Y : Type)\\n         (f : forall (x : X), F x -> Y)\\n         (t : Sigma (x : X), F x)\\n       => f (sigma1 t) (sigma2 t).\\n\\nArguments sigma_recursion {X F} Y _ _.
LHS: Definition sigma_recursion\\n  : forall (X : Type)\\n           (F : X -> Type)\\n           (Y : Type),\\n      (forall (x : X), F x -> Y) -> (Sigma (x : X), F x) -> Y
RHS: fun (X : Type)\\n         (F : X -> Type)\\n         (Y : Type)\\n         (f : forall (x : X), F x -> Y)\\n         (t : Sigma (x : X), F x)\\n       => f (sigma1 t) (sigma2 t).\\n\\nArguments sigma_recursion {X F} Y _ _.
SortKey: A

Label: 9ia68b8n
Name: Product
Class: Definition
File: src/base/construct.v
Begin: 270
End: 271
Content: Definition Product : Type -> Type -> Type\\n  := fun (X Y : Type) => Sigma (_ : X), Y.
LHS: Definition Product : Type -> Type -> Type
RHS: fun (X Y : Type) => Sigma (_ : X), Y.
SortKey: A

Label: c97wzdtw
Name: pair
Class: Definition
File: src/base/construct.v
Begin: 275
End: 279
Content: Definition pair : forall (X Y : Type), X -> Y -> Product X Y\\n  := fun (X Y : Type) (x : X) (y : Y)\\n       => sigma (@constant_function X Type Y) x y.\\n\\nArguments pair {X Y} _ _.
LHS: Definition pair : forall (X Y : Type), X -> Y -> Product X Y
RHS: fun (X Y : Type) (x : X) (y : Y)\\n       => sigma (@constant_function X Type Y) x y.\\n\\nArguments pair {X Y} _ _.
SortKey: A

Label: 9eptwq6k
Name: first
Class: Definition
File: src/base/construct.v
Begin: 283
End: 286
Content: Definition first : forall (X Y : Type), Product X Y -> X\\n  := fun (X Y : Type) (t : Product X Y) => sigma1 t.\\n\\nArguments first {X Y} _.
LHS: Definition first : forall (X Y : Type), Product X Y -> X
RHS: fun (X Y : Type) (t : Product X Y) => sigma1 t.\\n\\nArguments first {X Y} _.
SortKey: A

Label: og9uqzhe
Name: second
Class: Definition
File: src/base/construct.v
Begin: 290
End: 293
Content: Definition second : forall (X Y : Type), Product X Y -> Y\\n  := fun (X Y : Type) (t : Product X Y) => sigma2 t.\\n\\nArguments second {X Y} _.
LHS: Definition second : forall (X Y : Type), Product X Y -> Y
RHS: fun (X Y : Type) (t : Product X Y) => sigma2 t.\\n\\nArguments second {X Y} _.
SortKey: A

Label: ww805vp5
Name: product_induction
Class: Definition
File: src/base/construct.v
Begin: 297
End: 307
Content: Definition product_induction\\n  : forall (X Y : Type) (F : Product X Y -> Type),\\n      (forall (x : X) (y : Y), F (pair x y))\\n        -> forall (t : Product X Y), F t\\n  := fun (X Y : Type)\\n         (F : Product X Y -> Type)\\n         (f : forall (x : X) (y : Y), F (pair x y))\\n         (t : Product X Y)\\n       => f (first t) (second t).\\n\\nArguments product_induction {X Y F} _ _.
LHS: Definition product_induction\\n  : forall (X Y : Type) (F : Product X Y -> Type),\\n      (forall (x : X) (y : Y), F (pair x y))\\n        -> forall (t : Product X Y), F t
RHS: fun (X Y : Type)\\n         (F : Product X Y -> Type)\\n         (f : forall (x : X) (y : Y), F (pair x y))\\n         (t : Product X Y)\\n       => f (first t) (second t).\\n\\nArguments product_induction {X Y F} _ _.
SortKey: A

Label: e1hi7545
Name: uncurry
Class: Definition
File: src/base/construct.v
Begin: 311
End: 317
Content: Definition uncurry\\n  : forall (X Y : Type) (F : Product X Y -> Type),\\n      (forall (x : X) (y : Y), F (pair x y))\\n        -> forall (t : Product X Y), F t\\n  := @product_induction.\\n\\nArguments uncurry {X Y F} _ _.
LHS: Definition uncurry\\n  : forall (X Y : Type) (F : Product X Y -> Type),\\n      (forall (x : X) (y : Y), F (pair x y))\\n        -> forall (t : Product X Y), F t
RHS: @product_induction.\\n\\nArguments uncurry {X Y F} _ _.
SortKey: A

Label: g6p35mq1
Name: curry
Class: Definition
File: src/base/construct.v
Begin: 321
End: 332
Content: Definition curry\\n  : forall (X Y : Type) (F : Product X Y -> Type),\\n      (forall (t : Product X Y), F t)\\n        -> forall (x : X) (y : Y), F (pair x y)\\n  := fun (X Y : Type)\\n         (F : Product X Y -> Type)\\n         (g : forall (t : Product X Y), F t)\\n         (x : X)\\n         (y : Y)\\n       => g (pair x y).\\n\\nArguments curry {X Y F} _ _ _.
LHS: Definition curry\\n  : forall (X Y : Type) (F : Product X Y -> Type),\\n      (forall (t : Product X Y), F t)\\n        -> forall (x : X) (y : Y), F (pair x y)
RHS: fun (X Y : Type)\\n         (F : Product X Y -> Type)\\n         (g : forall (t : Product X Y), F t)\\n         (x : X)\\n         (y : Y)\\n       => g (pair x y).\\n\\nArguments curry {X Y F} _ _ _.
SortKey: A

Label: 9cz79pdm
Name: product_recursion
Class: Definition
File: src/base/construct.v
Begin: 336
End: 343
Content: Definition product_recursion\\n  : forall (X Y Z : Type), (X -> Y -> Z) -> Product X Y -> Z\\n  := fun (X Y Z : Type)\\n         (f : X -> Y -> Z)\\n         (t : Product X Y)\\n       => f (first t) (second t).\\n\\nArguments product_recursion {X Y Z} _ _.
LHS: Definition product_recursion\\n  : forall (X Y Z : Type), (X -> Y -> Z) -> Product X Y -> Z
RHS: fun (X Y Z : Type)\\n         (f : X -> Y -> Z)\\n         (t : Product X Y)\\n       => f (first t) (second t).\\n\\nArguments product_recursion {X Y Z} _ _.
SortKey: A

Label: d0923l5s
Name: PairFamily
Class: Definition
File: src/base/construct.v
Begin: 347
End: 352
Content: Definition PairFamily\\n  : forall (T : Type), (T -> Type) -> (T -> Type) -> T -> Type\\n  := fun (T : Type) (F : T -> Type) (G : T -> Type) (t : T)\\n       => Product (F t) (G t).\\n\\nArguments PairFamily {T} _ _ _.
LHS: Definition PairFamily\\n  : forall (T : Type), (T -> Type) -> (T -> Type) -> T -> Type
RHS: fun (T : Type) (F : T -> Type) (G : T -> Type) (t : T)\\n       => Product (F t) (G t).\\n\\nArguments PairFamily {T} _ _ _.
SortKey: A

Label: rgjbl4r2
Name: pair_function
Class: Definition
File: src/base/construct.v
Begin: 356
End: 371
Content: Definition pair_function\\n  : forall (T : Type)\\n           (F : T -> Type)\\n           (G : T -> Type),\\n      (forall (t : T), F t)\\n        -> (forall (t : T), G t)\\n          -> forall (t : T), Product (F t) (G t)\\n  := fun (T : Type)\\n         (F : T -> Type)\\n         (G : T -> Type)\\n         (f : forall (t : T), F t)\\n         (g : forall (t : T), G t)\\n         (t : T)\\n       => pair (f t) (g t).\\n\\nArguments  pair_function {T F G} _ _ _.
LHS: Definition pair_function\\n  : forall (T : Type)\\n           (F : T -> Type)\\n           (G : T -> Type),\\n      (forall (t : T), F t)\\n        -> (forall (t : T), G t)\\n          -> forall (t : T), Product (F t) (G t)
RHS: fun (T : Type)\\n         (F : T -> Type)\\n         (G : T -> Type)\\n         (f : forall (t : T), F t)\\n         (g : forall (t : T), G t)\\n         (t : T)\\n       => pair (f t) (g t).\\n\\nArguments  pair_function {T F G} _ _ _.
SortKey: A

Label: wqs9857v
Name: product_map
Class: Definition
File: src/base/construct.v
Begin: 375
End: 384
Content: Definition product_map\\n  : forall (X Y X' Y' : Type),\\n      (X -> X') -> (Y -> Y') -> Product X Y -> Product X' Y'\\n  := fun (X Y X' Y' : Type)\\n         (f : X -> X')\\n         (g : Y -> Y')\\n         (t : Product X Y)\\n       => pair (f (first t)) (g (second t)).\\n\\nArguments product_map {X Y X' Y'} _ _ _.
LHS: Definition product_map\\n  : forall (X Y X' Y' : Type),\\n      (X -> X') -> (Y -> Y') -> Product X Y -> Product X' Y'
RHS: fun (X Y X' Y' : Type)\\n         (f : X -> X')\\n         (g : Y -> Y')\\n         (t : Product X Y)\\n       => pair (f (first t)) (g (second t)).\\n\\nArguments product_map {X Y X' Y'} _ _ _.
SortKey: A

Label: fp5x8226
Name: Sum
Class: Definition
File: src/base/construct.v
Begin: 392
End: 395
Content: Definition Sum : Type -> Type -> Type\\n  := fun (X Y : Type)\\n       => let F : Boolean -> Type := boolean_recursion X Y\\n          in Sigma (b : Boolean), F b.
LHS: Definition Sum : Type -> Type -> Type
RHS: fun (X Y : Type)\\n       => let F : Boolean -> Type := boolean_recursion X Y\\n          in Sigma (b : Boolean), F b.
SortKey: A

Label: kknkg0c7
Name: left
Class: Definition
File: src/base/construct.v
Begin: 399
End: 402
Content: Definition left : forall (X Y : Type), X -> Sum X Y\\n  := fun (X Y : Type) (x : X) => sigma (boolean_recursion X Y) yes x.\\n\\nArguments left {X Y} _.
LHS: Definition left : forall (X Y : Type), X -> Sum X Y
RHS: fun (X Y : Type) (x : X) => sigma (boolean_recursion X Y) yes x.\\n\\nArguments left {X Y} _.
SortKey: A

Label: ma104yei
Name: right
Class: Definition
File: src/base/construct.v
Begin: 406
End: 409
Content: Definition right : forall (X Y : Type), Y -> Sum X Y\\n  := fun (X Y : Type) (y : Y) => sigma (boolean_recursion X Y) no y.\\n\\nArguments right {X Y} _.
LHS: Definition right : forall (X Y : Type), Y -> Sum X Y
RHS: fun (X Y : Type) (y : Y) => sigma (boolean_recursion X Y) no y.\\n\\nArguments right {X Y} _.
SortKey: A

Label: hrr9zb80
Name: sum_induction
Class: Definition
File: src/base/construct.v
Begin: 413
End: 434
Content: Definition sum_induction\\n  : forall (X Y : Type) (F : Sum X Y -> Type),\\n      (forall (x : X), F (left x)) -> (forall (y : Y), F (right y))\\n        -> forall (s : Sum X Y), F s\\n  := fun (X Y : Type)\\n         (F : Sum X Y -> Type)\\n         (f : forall (x : X), F (left x))\\n         (g : forall (y : Y), F (right y))\\n         (s : Sum X Y)\\n       =>\\n         let\\n           P : Boolean -> Type := boolean_recursion X Y\\n         in let\\n           Q : Boolean -> Type\\n             := fun (b : Boolean)\\n                  => forall (e : P b), F (sigma P b e)\\n         in let\\n           q : forall (b : Boolean), Q b := boolean_induction Q f g\\n         in\\n           q (sigma1 s) (sigma2 s).\\n\\nArguments sum_induction {X Y} F _ _ s.
LHS: Definition sum_induction\\n  : forall (X Y : Type) (F : Sum X Y -> Type),\\n      (forall (x : X), F (left x)) -> (forall (y : Y), F (right y))\\n        -> forall (s : Sum X Y), F s
RHS: fun (X Y : Type)\\n         (F : Sum X Y -> Type)\\n         (f : forall (x : X), F (left x))\\n         (g : forall (y : Y), F (right y))\\n         (s : Sum X Y)\\n       =>\\n         let\\n           P : Boolean -> Type := boolean_recursion X Y\\n         in let\\n           Q : Boolean -> Type\\n             := fun (b : Boolean)\\n                  => forall (e : P b), F (sigma P b e)\\n         in let\\n           q : forall (b : Boolean), Q b := boolean_induction Q f g\\n         in\\n           q (sigma1 s) (sigma2 s).\\n\\nArguments sum_induction {X Y} F _ _ s.
SortKey: A

Label: czz2aznf
Name: sum_recursion
Class: Definition
File: src/base/construct.v
Begin: 438
End: 454
Content: Definition sum_recursion\\n  : forall (X Y Z : Type), (X -> Z) -> (Y -> Z) -> Sum X Y -> Z\\n  := fun (X Y Z : Type)\\n         (f : X -> Z)\\n         (g : Y -> Z)\\n         (s : Sum X Y)\\n       =>\\n         let\\n           P : Boolean -> Type := boolean_recursion X Y\\n         in let\\n           Q : Boolean -> Type := fun (b : Boolean) => P b -> Z\\n         in let\\n           q : forall (b : Boolean), Q b := boolean_induction Q f g\\n         in\\n           q (sigma1 s) (sigma2 s).\\n\\nArguments sum_recursion {X Y Z} _ _ s.
LHS: Definition sum_recursion\\n  : forall (X Y Z : Type), (X -> Z) -> (Y -> Z) -> Sum X Y -> Z
RHS: fun (X Y Z : Type)\\n         (f : X -> Z)\\n         (g : Y -> Z)\\n         (s : Sum X Y)\\n       =>\\n         let\\n           P : Boolean -> Type := boolean_recursion X Y\\n         in let\\n           Q : Boolean -> Type := fun (b : Boolean) => P b -> Z\\n         in let\\n           q : forall (b : Boolean), Q b := boolean_induction Q f g\\n         in\\n           q (sigma1 s) (sigma2 s).\\n\\nArguments sum_recursion {X Y Z} _ _ s.
SortKey: A

Label: mrbbbxn0
Name: sum_map
Class: Definition
File: src/base/construct.v
Begin: 458
End: 470
Content: Definition sum_map\\n  : forall (X Y X' Y' : Type),\\n      (X -> X') -> (Y -> Y') -> Sum X Y -> Sum X' Y'\\n  := fun (X Y X' Y' : Type) (f : X -> X') (g : Y -> Y')\\n       =>\\n         let\\n           u : X -> Sum X' Y' := fun x => left (f x)\\n         in let\\n           v : Y -> Sum X' Y' := fun y => right (g y)\\n         in\\n           sum_recursion u v.\\n\\nArguments sum_map {X Y X' Y'} _ _ _.
LHS: Definition sum_map\\n  : forall (X Y X' Y' : Type),\\n      (X -> X') -> (Y -> Y') -> Sum X Y -> Sum X' Y'
RHS: fun (X Y X' Y' : Type) (f : X -> X') (g : Y -> Y')\\n       =>\\n         let\\n           u : X -> Sum X' Y' := fun x => left (f x)\\n         in let\\n           v : Y -> Sum X' Y' := fun y => right (g y)\\n         in\\n           sum_recursion u v.\\n\\nArguments sum_map {X Y X' Y'} _ _ _.
SortKey: A

Label: ave0dtr6
Name: "X -> Y"
Class: Notation
File: src/base/primitive.v
Begin: 8
End: 9
Content: Notation "X -> Y" := (forall (_ : X), Y)\\n  (at level 99, right associativity, Y at level 200).
LHS: Notation "X -> Y"
RHS: (forall (_ : X), Y)\\n  (at level 99, right associativity, Y at level 200).
SortKey: J

Label: 776l3lwg
Name: False
Class: Inductive
File: src/base/primitive.v
Begin: 17
End: 17
Content: Inductive False: Type := .
LHS: Inductive False: Type
RHS: .
SortKey: D

Label: b79a8cj0
Name: false_induction
Class: Definition
File: src/base/primitive.v
Begin: 21
End: 23
Content: Definition false_induction\\n  : forall (F : False -> Type) (x : False), F x\\n  := False_rect.
LHS: Definition false_induction\\n  : forall (F : False -> Type) (x : False), F x
RHS: False_rect.
SortKey: A

Label: 815by4qc
Name: True
Class: Inductive
File: src/base/primitive.v
Begin: 31
End: 31
Content: Inductive True : Type := only : True.
LHS: Inductive True : Type
RHS: only : True.
SortKey: D

Label: xfdlpg97
Name: true_induction
Class: Definition
File: src/base/primitive.v
Begin: 35
End: 37
Content: Definition true_induction\\n  : forall (F : True -> Type), F only -> forall (x : True), F x\\n  := True_rect.
LHS: Definition true_induction\\n  : forall (F : True -> Type), F only -> forall (x : True), F x
RHS: True_rect.
SortKey: A

Label: 2xu2p4rk
Name: Boolean
Class: Inductive
File: src/base/primitive.v
Begin: 45
End: 45
Content: Inductive Boolean : Type := yes : Boolean | no : Boolean.
LHS: Inductive Boolean : Type
RHS: yes : Boolean | no : Boolean.
SortKey: D

Label: e8s65324
Name: boolean_induction
Class: Definition
File: src/base/primitive.v
Begin: 49
End: 52
Content: Definition boolean_induction\\n  : forall (F : Boolean -> Type),\\n      F yes -> F no -> forall (x : Boolean), F x\\n  := Boolean_rect.
LHS: Definition boolean_induction\\n  : forall (F : Boolean -> Type),\\n      F yes -> F no -> forall (x : Boolean), F x
RHS: Boolean_rect.
SortKey: A

Label: x6u83qds
Name: Natural
Class: Inductive
File: src/base/primitive.v
Begin: 60
End: 61
Content: Inductive Natural : Type\\n  := zero : Natural | successor : Natural -> Natural.
LHS: Inductive Natural : Type
RHS: zero : Natural | successor : Natural -> Natural.
SortKey: D

Label: mblpgwu0
Name: natural_induction
Class: Definition
File: src/base/primitive.v
Begin: 65
End: 70
Content: Definition natural_induction\\n  : forall (F : Natural -> Type),\\n      F zero\\n        -> (forall (n : Natural), F n -> F (successor n))\\n            -> forall (n : Natural), F n\\n  := Natural_rect.
LHS: Definition natural_induction\\n  : forall (F : Natural -> Type),\\n      F zero\\n        -> (forall (n : Natural), F n -> F (successor n))\\n            -> forall (n : Natural), F n
RHS: Natural_rect.
SortKey: A

Label: whnabw73
Name: Equal
Class: Inductive
File: src/base/primitive.v
Begin: 78
End: 82
Content: Inductive Equal (X : Type) (x : X) : X -> Type\\n  := reflexive : Equal X x x.\\n\\nArguments Equal {X} x  _.\\nArguments reflexive {X} x.
LHS: Inductive Equal (X : Type) (x : X) : X -> Type
RHS: reflexive : Equal X x x.\\n\\nArguments Equal {X} x  _.\\nArguments reflexive {X} x.
SortKey: D

Label: xxyabzuf
Name: equal_induction
Class: Definition
File: src/base/primitive.v
Begin: 86
End: 93
Content: Definition equal_induction\\n  : forall (X : Type)\\n           (x : X)\\n           (F : forall (y : X), Equal x y -> Type),\\n      F x (reflexive x) -> forall (y : X) (p : Equal x y), F y p\\n  := Equal_rect.\\n\\nArguments equal_induction {X} x F _ y p.
LHS: Definition equal_induction\\n  : forall (X : Type)\\n           (x : X)\\n           (F : forall (y : X), Equal x y -> Type),\\n      F x (reflexive x) -> forall (y : X) (p : Equal x y), F y p
RHS: Equal_rect.\\n\\nArguments equal_induction {X} x F _ y p.
SortKey: A

Label: agn2f6jd
Name: _Sigma
Class: Record
File: src/base/primitive.v
Begin: 101
End: 107
Content: Record _Sigma (X : Type) (F : X -> Type) : Type\\n  := sigma {sigma1 : X; sigma2 : F sigma1}.\\n\\nArguments _Sigma {X} F.\\nArguments sigma {X} F _ _.\\nArguments sigma1 {X F} _.\\nArguments sigma2 {X F} _.
LHS: Record _Sigma (X : Type) (F : X -> Type) : Type
RHS: sigma {sigma1 : X; sigma2 : F sigma1}.\\n\\nArguments _Sigma {X} F.\\nArguments sigma {X} F _ _.\\nArguments sigma1 {X F} _.\\nArguments sigma2 {X F} _.
SortKey: G

Label: 497e8me5
Name: "'Sigma' x .. y , P"
Class: Notation
File: src/base/primitive.v
Begin: 111
End: 113
Content: Notation "'Sigma' x .. y , P"\\n  := (_Sigma (fun x => .. (_Sigma (fun y => P)) ..))\\n       (at level 200, x binder, y binder, right associativity).
LHS: Notation "'Sigma' x .. y , P"
RHS: (_Sigma (fun x => .. (_Sigma (fun y => P)) ..))\\n       (at level 200, x binder, y binder, right associativity).
SortKey: J

Label: 909vtogz
Name: NA
Class: Vernacular
File: src/base/same.v
Begin: 8
End: 9
Content: Require Import ufcoq.base.primitive.\\nRequire Import ufcoq.base.construct.
LHS: NA
RHS: NA
SortKey: T

Label: ryjyw5yo
Name: _function_eta_conversion
Class: Example
File: src/base/same.v
Begin: 17
End: 21
Content: Example _function_eta_conversion\\n  : forall (X : Type) (F : X -> Type) (f : forall (x : X), F x),\\n      Equal f (fun (x : X) => f x)\\n  := fun (X : Type) (F : X -> Type) (f : forall (x : X), F x)\\n      => reflexive f.
LHS: Example _function_eta_conversion\\n  : forall (X : Type) (F : X -> Type) (f : forall (x : X), F x),\\n      Equal f (fun (x : X) => f x)
RHS: fun (X : Type) (F : X -> Type) (f : forall (x : X), F x)\\n      => reflexive f.
SortKey: Z

Label: r3y1kpvr
Name: _function_compose_associative
Class: Example
File: src/base/same.v
Begin: 25
End: 42
Content: Example _function_compose_associative\\n  : forall (W : Type)\\n           (X : Type)\\n           (Y : Type)\\n           (G : Y -> Type)\\n           (g : forall (y : Y), G y)\\n           (f : X -> Y)\\n           (e : W -> X),\\n      Equal (function_compose (function_compose g f) e)\\n            (function_compose g (function_compose f e))\\n  := fun (W : Type)\\n         (X : Type)\\n         (Y : Type)\\n         (G : Y -> Type)\\n         (g : forall (y : Y), G y)\\n         (f : X -> Y)\\n         (e : W -> X)\\n       => reflexive (function_compose (function_compose g f) e).
LHS: Example _function_compose_associative\\n  : forall (W : Type)\\n           (X : Type)\\n           (Y : Type)\\n           (G : Y -> Type)\\n           (g : forall (y : Y), G y)\\n           (f : X -> Y)\\n           (e : W -> X),\\n      Equal (function_compose (function_compose g f) e)\\n            (function_compose g (function_compose f e))
RHS: fun (W : Type)\\n         (X : Type)\\n         (Y : Type)\\n         (G : Y -> Type)\\n         (g : forall (y : Y), G y)\\n         (f : X -> Y)\\n         (e : W -> X)\\n       => reflexive (function_compose (function_compose g f) e).
SortKey: Z

Label: hso05la4
Name: _function_compose_left_unit
Class: Example
File: src/base/same.v
Begin: 46
End: 50
Content: Example _function_compose_left_unit\\n  : forall (X Y : Type) (f : X -> Y),\\n      Equal f (function_compose (@identity_function Y) f)\\n  := fun (X Y : Type) (f : X -> Y)\\n       => reflexive f.
LHS: Example _function_compose_left_unit\\n  : forall (X Y : Type) (f : X -> Y),\\n      Equal f (function_compose (@identity_function Y) f)
RHS: fun (X Y : Type) (f : X -> Y)\\n       => reflexive f.
SortKey: Z

Label: ey5cl868
Name: _function_compose_right_unit
Class: Example
File: src/base/same.v
Begin: 54
End: 62
Content: Example _function_compose_right_unit\\n  : forall (X : Type)\\n           (G : X -> Type)\\n           (g : forall (x : X), G x),\\n      Equal g (function_compose  g (@identity_function X))\\n  := fun (X : Type)\\n         (G : X -> Type)\\n         (g : forall (x : X), G x)\\n       => reflexive g.
LHS: Example _function_compose_right_unit\\n  : forall (X : Type)\\n           (G : X -> Type)\\n           (g : forall (x : X), G x),\\n      Equal g (function_compose  g (@identity_function X))
RHS: fun (X : Type)\\n         (G : X -> Type)\\n         (g : forall (x : X), G x)\\n       => reflexive g.
SortKey: Z

Label: tuh9sgix
Name: _true_induction_only
Class: Example
File: src/base/same.v
Begin: 70
End: 74
Content: Example _true_induction_only\\n  : forall (F : True -> Type) (x : F only),\\n      Equal x (true_induction F x only)\\n  := fun (F : True -> Type) (x : F only)\\n       => reflexive x.
LHS: Example _true_induction_only\\n  : forall (F : True -> Type) (x : F only),\\n      Equal x (true_induction F x only)
RHS: fun (F : True -> Type) (x : F only)\\n       => reflexive x.
SortKey: Z

Label: iww5ck0g
Name: _true_recursion_only
Class: Example
File: src/base/same.v
Begin: 78
End: 80
Content: Example _true_recursion_only\\n  : forall (X : Type) (x : X), Equal x (true_recursion x only)\\n  := fun (X : Type) (x : X) => reflexive x.
LHS: Example _true_recursion_only\\n  : forall (X : Type) (x : X), Equal x (true_recursion x only)
RHS: fun (X : Type) (x : X) => reflexive x.
SortKey: Z

Label: qgyqpcz3
Name: _to_true_only
Class: Example
File: src/base/same.v
Begin: 84
End: 86
Content: Example _to_true_only\\n  : forall (X : Type) (x : X), Equal only (to_true x)\\n  := fun (X : Type) (x : X) => reflexive only.
LHS: Example _to_true_only\\n  : forall (X : Type) (x : X), Equal only (to_true x)
RHS: fun (X : Type) (x : X) => reflexive only.
SortKey: Z

Label: ogo7jox4
Name: _boolean_induction_yes
Class: Example
File: src/base/same.v
Begin: 94
End: 97
Content: Example _boolean_induction_yes\\n  : forall (F : Boolean -> Type) (y : F yes) (n : F no),\\n      Equal y (boolean_induction F y n yes)\\n  := fun (F : Boolean -> Type) (y : F yes) (n : F no) => reflexive y.
LHS: Example _boolean_induction_yes\\n  : forall (F : Boolean -> Type) (y : F yes) (n : F no),\\n      Equal y (boolean_induction F y n yes)
RHS: fun (F : Boolean -> Type) (y : F yes) (n : F no) => reflexive y.
SortKey: Z

Label: 6ly41ngr
Name: _boolean_induction_no
Class: Example
File: src/base/same.v
Begin: 101
End: 104
Content: Example _boolean_induction_no\\n  : forall (F : Boolean -> Type) (y : F yes) (n : F no),\\n      Equal n (boolean_induction F y n no)\\n  := fun (F : Boolean -> Type) (y : F yes) (n : F no) => reflexive n.
LHS: Example _boolean_induction_no\\n  : forall (F : Boolean -> Type) (y : F yes) (n : F no),\\n      Equal n (boolean_induction F y n no)
RHS: fun (F : Boolean -> Type) (y : F yes) (n : F no) => reflexive n.
SortKey: Z

Label: 2wynnkw2
Name: _boolean_recursion_yes
Class: Example
File: src/base/same.v
Begin: 108
End: 110
Content: Example _boolean_recursion_yes\\n  : forall (X : Type) (y n : X), Equal y (boolean_recursion y n yes)\\n  := fun (X : Type) (y n : X) => reflexive y.
LHS: Example _boolean_recursion_yes\\n  : forall (X : Type) (y n : X), Equal y (boolean_recursion y n yes)
RHS: fun (X : Type) (y n : X) => reflexive y.
SortKey: Z

Label: 4cga60mp
Name: _boolean_recursion_no
Class: Example
File: src/base/same.v
Begin: 114
End: 116
Content: Example _boolean_recursion_no\\n  : forall (X : Type) (y n : X), Equal n (boolean_recursion y n no)\\n  := fun (X : Type) (y n : X) => reflexive n.
LHS: Example _boolean_recursion_no\\n  : forall (X : Type) (y n : X), Equal n (boolean_recursion y n no)
RHS: fun (X : Type) (y n : X) => reflexive n.
SortKey: Z

Label: p33ig2te
Name: _natural_induction_zero
Class: Example
File: src/base/same.v
Begin: 124
End: 132
Content: Example _natural_induction_zero\\n  : forall (F : Natural -> Type)\\n           (z : F zero)\\n           (s : forall (n : Natural), F n -> F (successor n)),\\n      Equal z (natural_induction F z s zero)\\n  := fun (F : Natural -> Type)\\n         (z : F zero)\\n         (s : forall (n : Natural), F n -> F (successor n))\\n       => reflexive z.
LHS: Example _natural_induction_zero\\n  : forall (F : Natural -> Type)\\n           (z : F zero)\\n           (s : forall (n : Natural), F n -> F (successor n)),\\n      Equal z (natural_induction F z s zero)
RHS: fun (F : Natural -> Type)\\n         (z : F zero)\\n         (s : forall (n : Natural), F n -> F (successor n))\\n       => reflexive z.
SortKey: Z

Label: ojb7dh9z
Name: _natural_induction_successor
Class: Example
File: src/base/same.v
Begin: 136
End: 147
Content: Example _natural_induction_successor\\n  : forall (F : Natural -> Type)\\n           (z : F zero)\\n           (s : forall (n : Natural), F n -> F (successor n))\\n           (n : Natural),\\n      Equal (s n (natural_induction F z s n))\\n            (natural_induction F z s (successor n))\\n  := fun (F : Natural -> Type)\\n         (z : F zero)\\n         (s : forall (n : Natural), F n -> F (successor n))\\n         (n : Natural)\\n       => reflexive (s n (natural_induction F z s n)).
LHS: Example _natural_induction_successor\\n  : forall (F : Natural -> Type)\\n           (z : F zero)\\n           (s : forall (n : Natural), F n -> F (successor n))\\n           (n : Natural),\\n      Equal (s n (natural_induction F z s n))\\n            (natural_induction F z s (successor n))
RHS: fun (F : Natural -> Type)\\n         (z : F zero)\\n         (s : forall (n : Natural), F n -> F (successor n))\\n         (n : Natural)\\n       => reflexive (s n (natural_induction F z s n)).
SortKey: Z

Label: rzfhv79d
Name: _natural_recursion_zero
Class: Example
File: src/base/same.v
Begin: 151
End: 155
Content: Example _natural_recursion_zero\\n  : forall (X : Type) (z : X) (s : Natural -> X -> X),\\n      Equal z (natural_recursion z s zero)\\n  := fun (X : Type) (z : X) (s : Natural -> X -> X)\\n       => reflexive z.
LHS: Example _natural_recursion_zero\\n  : forall (X : Type) (z : X) (s : Natural -> X -> X),\\n      Equal z (natural_recursion z s zero)
RHS: fun (X : Type) (z : X) (s : Natural -> X -> X)\\n       => reflexive z.
SortKey: Z

Label: hrrncvpb
Name: _natural_recursion_successor
Class: Example
File: src/base/same.v
Begin: 159
End: 164
Content: Example _natural_recursion_successor\\n  : forall (X : Type) (z : X) (s : Natural -> X -> X) (n : Natural),\\n      Equal (s n (natural_recursion z s n))\\n            (natural_recursion z s (successor n))\\n  := fun (X : Type) (z : X) (s : Natural -> X -> X) (n : Natural)\\n     => reflexive (s n (natural_recursion z s n)).
LHS: Example _natural_recursion_successor\\n  : forall (X : Type) (z : X) (s : Natural -> X -> X) (n : Natural),\\n      Equal (s n (natural_recursion z s n))\\n            (natural_recursion z s (successor n))
RHS: fun (X : Type) (z : X) (s : Natural -> X -> X) (n : Natural)\\n     => reflexive (s n (natural_recursion z s n)).
SortKey: Z

Label: upakg9n0
Name: _natural_recursion_simple_zero
Class: Example
File: src/base/same.v
Begin: 168
End: 172
Content: Example _natural_recursion_simple_zero\\n  : forall (X : Type) (z : X) (s : X -> X),\\n      Equal z (natural_recursion_simple z s zero)\\n  := fun (X : Type) (z : X) (s : X -> X)\\n       => reflexive z.
LHS: Example _natural_recursion_simple_zero\\n  : forall (X : Type) (z : X) (s : X -> X),\\n      Equal z (natural_recursion_simple z s zero)
RHS: fun (X : Type) (z : X) (s : X -> X)\\n       => reflexive z.
SortKey: Z

Label: tsfievor
Name: _natural_recursion_simple_successor
Class: Example
File: src/base/same.v
Begin: 176
End: 181
Content: Example _natural_recursion_simple_successor\\n  : forall (X : Type) (z : X) (s : X -> X) (n : Natural),\\n      Equal (s (natural_recursion_simple z s n))\\n            (natural_recursion_simple z s (successor n))\\n  := fun (X : Type) (z : X) (s : X -> X) (n : Natural)\\n       => reflexive (s (natural_recursion_simple z s n)).
LHS: Example _natural_recursion_simple_successor\\n  : forall (X : Type) (z : X) (s : X -> X) (n : Natural),\\n      Equal (s (natural_recursion_simple z s n))\\n            (natural_recursion_simple z s (successor n))
RHS: fun (X : Type) (z : X) (s : X -> X) (n : Natural)\\n       => reflexive (s (natural_recursion_simple z s n)).
SortKey: Z

Label: fznk9p3u
Name: _equal_induction_reflexive
Class: Example
File: src/base/same.v
Begin: 189
End: 199
Content: Example _equal_induction_reflexive\\n  : forall (X : Type)\\n           (x : X)\\n           (F : forall (y : X), Equal x y -> Type)\\n           (e : F x (reflexive x)),\\n      Equal e (equal_induction x F e x (reflexive x))\\n  := fun (X : Type)\\n         (x : X)\\n         (F : forall (y : X), Equal x y -> Type)\\n         (e : F x (reflexive x))\\n       => reflexive e.
LHS: Example _equal_induction_reflexive\\n  : forall (X : Type)\\n           (x : X)\\n           (F : forall (y : X), Equal x y -> Type)\\n           (e : F x (reflexive x)),\\n      Equal e (equal_induction x F e x (reflexive x))
RHS: fun (X : Type)\\n         (x : X)\\n         (F : forall (y : X), Equal x y -> Type)\\n         (e : F x (reflexive x))\\n       => reflexive e.
SortKey: Z

Label: obnor2k3
Name: _transport_reflexive
Class: Example
File: src/base/same.v
Begin: 203
End: 207
Content: Example _transport_reflexive\\n  : forall (X : Type) (F : X -> Type) (x y : X),\\n      Equal (@identity_function (F x)) (transport F (reflexive x))\\n  := fun (X : Type) (F : X -> Type) (x y : X)\\n       => reflexive (@identity_function (F x)).
LHS: Example _transport_reflexive\\n  : forall (X : Type) (F : X -> Type) (x y : X),\\n      Equal (@identity_function (F x)) (transport F (reflexive x))
RHS: fun (X : Type) (F : X -> Type) (x y : X)\\n       => reflexive (@identity_function (F x)).
SortKey: Z

Label: iqo3w2uh
Name: _transport_inverse_reflexive
Class: Example
File: src/base/same.v
Begin: 211
End: 216
Content: Example _transport_inverse_reflexive\\n  : forall (X : Type) (F : X -> Type) (x y : X),\\n      Equal (@identity_function (F x))\\n            (transport_inverse F (reflexive x))\\n  := fun (X : Type) (F : X -> Type) (x y : X)\\n       => reflexive (@identity_function (F x)).
LHS: Example _transport_inverse_reflexive\\n  : forall (X : Type) (F : X -> Type) (x y : X),\\n      Equal (@identity_function (F x))\\n            (transport_inverse F (reflexive x))
RHS: fun (X : Type) (F : X -> Type) (x y : X)\\n       => reflexive (@identity_function (F x)).
SortKey: Z

Label: qts05vtg
Name: _sigma_type_eta_conversion
Class: Example
File: src/base/same.v
Begin: 224
End: 228
Content: Example _sigma_type_eta_conversion\\n  : forall (X : Type) (F : X -> Type) (t : Sigma (x : X), F x),\\n      Equal t (sigma F (sigma1 t) (sigma2 t))\\n  := fun (X : Type) (F : X -> Type) (t : Sigma (x : X), F x)\\n       => reflexive t.
LHS: Example _sigma_type_eta_conversion\\n  : forall (X : Type) (F : X -> Type) (t : Sigma (x : X), F x),\\n      Equal t (sigma F (sigma1 t) (sigma2 t))
RHS: fun (X : Type) (F : X -> Type) (t : Sigma (x : X), F x)\\n       => reflexive t.
SortKey: Z

Label: mrl11i2o
Name: _sigma_curry_uncurry
Class: Example
File: src/base/same.v
Begin: 232
End: 242
Content: Example _sigma_curry_uncurry\\n  : forall (X : Type)\\n           (F : X -> Type)\\n           (G : (Sigma (x : X), F x) -> Type)\\n           (f : forall (x : X) (y : F x), G (sigma F x y)),\\n      Equal f (sigma_curry (sigma_uncurry f))\\n  := fun (X : Type)\\n         (F : X -> Type)\\n         (G : (Sigma (x : X), F x) -> Type)\\n         (f : forall (x : X) (y : F x), G (sigma F x y))\\n       => reflexive f.
LHS: Example _sigma_curry_uncurry\\n  : forall (X : Type)\\n           (F : X -> Type)\\n           (G : (Sigma (x : X), F x) -> Type)\\n           (f : forall (x : X) (y : F x), G (sigma F x y)),\\n      Equal f (sigma_curry (sigma_uncurry f))
RHS: fun (X : Type)\\n         (F : X -> Type)\\n         (G : (Sigma (x : X), F x) -> Type)\\n         (f : forall (x : X) (y : F x), G (sigma F x y))\\n       => reflexive f.
SortKey: Z

Label: 4zlly4cd
Name: _sigma_uncurry_curry
Class: Example
File: src/base/same.v
Begin: 246
End: 256
Content: Example _sigma_uncurry_curry\\n  : forall (X : Type)\\n           (F : X -> Type)\\n           (G : (Sigma (x : X), F x) -> Type)\\n           (g : forall (t : Sigma (x : X), F x), G t),\\n      Equal g (sigma_uncurry (sigma_curry g))\\n  := fun (X : Type)\\n         (F : X -> Type)\\n         (G : (Sigma (x : X), F x) -> Type)\\n         (g : forall (t : Sigma (x : X), F x), G t)\\n       => reflexive g.
LHS: Example _sigma_uncurry_curry\\n  : forall (X : Type)\\n           (F : X -> Type)\\n           (G : (Sigma (x : X), F x) -> Type)\\n           (g : forall (t : Sigma (x : X), F x), G t),\\n      Equal g (sigma_uncurry (sigma_curry g))
RHS: fun (X : Type)\\n         (F : X -> Type)\\n         (G : (Sigma (x : X), F x) -> Type)\\n         (g : forall (t : Sigma (x : X), F x), G t)\\n       => reflexive g.
SortKey: Z

Label: wruha80w
Name: _product_eta_conversion
Class: Example
File: src/base/same.v
Begin: 264
End: 268
Content: Example _product_eta_conversion\\n  : forall (X Y : Type) (t : Product X Y),\\n      Equal t (pair (first t) (second t))\\n  := fun (X Y : Type) (t : Product X Y)\\n       => reflexive t.
LHS: Example _product_eta_conversion\\n  : forall (X Y : Type) (t : Product X Y),\\n      Equal t (pair (first t) (second t))
RHS: fun (X Y : Type) (t : Product X Y)\\n       => reflexive t.
SortKey: Z

Label: h1vgtr2g
Name: _curry_uncurry
Class: Example
File: src/base/same.v
Begin: 272
End: 280
Content: Example _curry_uncurry\\n  : forall (X Y : Type)\\n           (F : Product X Y -> Type)\\n           (f : forall (x : X) (y : Y), F (pair x y)),\\n        Equal f (curry (uncurry f))\\n  := fun (X Y : Type)\\n         (F : Product X Y -> Type)\\n         (f : forall (x : X) (y : Y), F (pair x y))\\n       => reflexive f.
LHS: Example _curry_uncurry\\n  : forall (X Y : Type)\\n           (F : Product X Y -> Type)\\n           (f : forall (x : X) (y : Y), F (pair x y)),\\n        Equal f (curry (uncurry f))
RHS: fun (X Y : Type)\\n         (F : Product X Y -> Type)\\n         (f : forall (x : X) (y : Y), F (pair x y))\\n       => reflexive f.
SortKey: Z

Label: u70g12vv
Name: _uncurry_curry
Class: Example
File: src/base/same.v
Begin: 284
End: 292
Content: Example _uncurry_curry\\n  : forall (X Y : Type)\\n           (F : Product X Y -> Type)\\n           (g : forall (t : Product X Y), F t),\\n      Equal g (uncurry (curry g))\\n  := fun (X Y : Type)\\n         (F : Product X Y -> Type)\\n         (g : forall (t : Product X Y), F t)\\n       => reflexive g.
LHS: Example _uncurry_curry\\n  : forall (X Y : Type)\\n           (F : Product X Y -> Type)\\n           (g : forall (t : Product X Y), F t),\\n      Equal g (uncurry (curry g))
RHS: fun (X Y : Type)\\n         (F : Product X Y -> Type)\\n         (g : forall (t : Product X Y), F t)\\n       => reflexive g.
SortKey: Z

Label: rdugvrpr
Name: _pair_function_first
Class: Example
File: src/base/same.v
Begin: 296
End: 310
Content: Example _pair_function_first\\n  : forall (T : Type)\\n           (F : T -> Type)\\n           (G : T -> Type)\\n           (f : forall (t : T), F t)\\n           (g : forall (t : T), G t)\\n           (t : T),\\n      Equal (f t) (first (pair_function f g t))\\n  := fun (T : Type)\\n         (F : T -> Type)\\n         (G : T -> Type)\\n         (f : forall   (t : T), F t)\\n         (g : forall (t : T), G t)\\n         (t : T)\\n       => reflexive (f t).
LHS: Example _pair_function_first\\n  : forall (T : Type)\\n           (F : T -> Type)\\n           (G : T -> Type)\\n           (f : forall (t : T), F t)\\n           (g : forall (t : T), G t)\\n           (t : T),\\n      Equal (f t) (first (pair_function f g t))
RHS: fun (T : Type)\\n         (F : T -> Type)\\n         (G : T -> Type)\\n         (f : forall   (t : T), F t)\\n         (g : forall (t : T), G t)\\n         (t : T)\\n       => reflexive (f t).
SortKey: Z

Label: z30hsvte
Name: _pair_function_second
Class: Example
File: src/base/same.v
Begin: 314
End: 328
Content: Example _pair_function_second\\n  : forall (T : Type)\\n           (F : T -> Type)\\n           (G : T -> Type)\\n           (f : forall (t : T), F t)\\n           (g : forall (t : T), G t)\\n           (t : T),\\n      Equal (g t) (second (pair_function f g t))\\n  := fun (T : Type)\\n         (F : T -> Type)\\n         (G : T -> Type)\\n         (f : forall   (t : T), F t)\\n         (g : forall (t : T), G t)\\n         (t : T)\\n       => reflexive (g t).
LHS: Example _pair_function_second\\n  : forall (T : Type)\\n           (F : T -> Type)\\n           (G : T -> Type)\\n           (f : forall (t : T), F t)\\n           (g : forall (t : T), G t)\\n           (t : T),\\n      Equal (g t) (second (pair_function f g t))
RHS: fun (T : Type)\\n         (F : T -> Type)\\n         (G : T -> Type)\\n         (f : forall   (t : T), F t)\\n         (g : forall (t : T), G t)\\n         (t : T)\\n       => reflexive (g t).
SortKey: Z

Label: sh7mqmkt
Name: _product_map_first
Class: Example
File: src/base/same.v
Begin: 332
End: 341
Content: Example _product_map_first\\n  : forall (X Y X' Y' : Type)\\n           (f : X -> X')\\n           (g : Y -> Y'),\\n      Equal (function_compose f first)\\n            (function_compose first (product_map f g))\\n  := fun (X Y X' Y' : Type)\\n         (f : X -> X')\\n         (g : Y -> Y')\\n       => reflexive (function_compose f first).
LHS: Example _product_map_first\\n  : forall (X Y X' Y' : Type)\\n           (f : X -> X')\\n           (g : Y -> Y'),\\n      Equal (function_compose f first)\\n            (function_compose first (product_map f g))
RHS: fun (X Y X' Y' : Type)\\n         (f : X -> X')\\n         (g : Y -> Y')\\n       => reflexive (function_compose f first).
SortKey: Z

Label: 2cjp777x
Name: _product_map_second
Class: Example
File: src/base/same.v
Begin: 345
End: 354
Content: Example _product_map_second\\n  : forall (X Y X' Y' : Type)\\n           (f : X -> X')\\n           (g : Y -> Y'),\\n      Equal (function_compose g second)\\n            (function_compose second (product_map f g))\\n  := fun (X Y X' Y' : Type)\\n         (f : X -> X')\\n         (g : Y -> Y')\\n       => reflexive (function_compose g second).
LHS: Example _product_map_second\\n  : forall (X Y X' Y' : Type)\\n           (f : X -> X')\\n           (g : Y -> Y'),\\n      Equal (function_compose g second)\\n            (function_compose second (product_map f g))
RHS: fun (X Y X' Y' : Type)\\n         (f : X -> X')\\n         (g : Y -> Y')\\n       => reflexive (function_compose g second).
SortKey: Z

Label: hut1r4st
Name: _sum_induction_left
Class: Example
File: src/base/same.v
Begin: 362
End: 372
Content: Example _sum_induction_left\\n  : forall (X Y : Type)\\n           (F : Sum X Y -> Type)\\n           (f : forall (x : X), F (left x))\\n           (g : forall (y : Y), F (right y)),\\n      Equal f (function_compose (sum_induction F f g) left)\\n  := fun (X Y : Type)\\n         (F : Sum X Y -> Type)\\n         (f : forall (x : X), F (left x))\\n         (g : forall (y : Y), F (right y))\\n       => reflexive f.
LHS: Example _sum_induction_left\\n  : forall (X Y : Type)\\n           (F : Sum X Y -> Type)\\n           (f : forall (x : X), F (left x))\\n           (g : forall (y : Y), F (right y)),\\n      Equal f (function_compose (sum_induction F f g) left)
RHS: fun (X Y : Type)\\n         (F : Sum X Y -> Type)\\n         (f : forall (x : X), F (left x))\\n         (g : forall (y : Y), F (right y))\\n       => reflexive f.
SortKey: Z

Label: w7zh5r1a
Name: _sum_induction_right
Class: Example
File: src/base/same.v
Begin: 376
End: 386
Content: Example _sum_induction_right\\n  : forall (X Y : Type)\\n           (F : Sum X Y -> Type)\\n           (f : forall (x : X), F (left x))\\n           (g : forall (y : Y), F (right y)),\\n      Equal g (function_compose (sum_induction F f g) right)\\n  := fun (X Y : Type)\\n         (F : Sum X Y -> Type)\\n         (f : forall (x : X), F (left x))\\n         (g : forall (y : Y), F (right y))\\n       => reflexive g.
LHS: Example _sum_induction_right\\n  : forall (X Y : Type)\\n           (F : Sum X Y -> Type)\\n           (f : forall (x : X), F (left x))\\n           (g : forall (y : Y), F (right y)),\\n      Equal g (function_compose (sum_induction F f g) right)
RHS: fun (X Y : Type)\\n         (F : Sum X Y -> Type)\\n         (f : forall (x : X), F (left x))\\n         (g : forall (y : Y), F (right y))\\n       => reflexive g.
SortKey: Z

Label: jwfgf3zw
Name: _sum_recursion_left
Class: Example
File: src/base/same.v
Begin: 390
End: 398
Content: Example _sum_recursion_left\\n  : forall (X Y Z : Type)\\n           (f : X -> Z)\\n           (g : Y -> Z),\\n      Equal f (function_compose (sum_recursion f g) left)\\n  := fun (X Y Z : Type)\\n         (f : X -> Z)\\n         (g : Y -> Z)\\n       => reflexive f.
LHS: Example _sum_recursion_left\\n  : forall (X Y Z : Type)\\n           (f : X -> Z)\\n           (g : Y -> Z),\\n      Equal f (function_compose (sum_recursion f g) left)
RHS: fun (X Y Z : Type)\\n         (f : X -> Z)\\n         (g : Y -> Z)\\n       => reflexive f.
SortKey: Z

Label: ll3xza2h
Name: _sum_recursion_right
Class: Example
File: src/base/same.v
Begin: 402
End: 410
Content: Example _sum_recursion_right\\n  : forall (X Y Z : Type)\\n           (f : X -> Z)\\n           (g : Y -> Z),\\n      Equal g (function_compose (sum_recursion f g) right)\\n  := fun (X Y Z : Type)\\n         (f : X -> Z)\\n         (g : Y -> Z)\\n       => reflexive g.
LHS: Example _sum_recursion_right\\n  : forall (X Y Z : Type)\\n           (f : X -> Z)\\n           (g : Y -> Z),\\n      Equal g (function_compose (sum_recursion f g) right)
RHS: fun (X Y Z : Type)\\n         (f : X -> Z)\\n         (g : Y -> Z)\\n       => reflexive g.
SortKey: Z

Label: eb0iol83
Name: _sum_map_left
Class: Example
File: src/base/same.v
Begin: 414
End: 423
Content: Example _sum_map_left\\n  : forall (X Y X' Y' : Type)\\n           (f : X -> X')\\n           (g : Y -> Y'),\\n      Equal (function_compose left f)\\n            (function_compose (sum_map f g) left)\\n  := fun (X Y X' Y' : Type)\\n         (f : X -> X')\\n         (g : Y -> Y')\\n       => reflexive (function_compose left f).
LHS: Example _sum_map_left\\n  : forall (X Y X' Y' : Type)\\n           (f : X -> X')\\n           (g : Y -> Y'),\\n      Equal (function_compose left f)\\n            (function_compose (sum_map f g) left)
RHS: fun (X Y X' Y' : Type)\\n         (f : X -> X')\\n         (g : Y -> Y')\\n       => reflexive (function_compose left f).
SortKey: Z

Label: minkb801
Name: _sum_map_right
Class: Example
File: src/base/same.v
Begin: 427
End: 436
Content: Example _sum_map_right\\n  : forall (X Y X' Y' : Type)\\n           (f : X -> X')\\n           (g : Y -> Y'),\\n      Equal (function_compose right g)\\n            (function_compose (sum_map f g) right)\\n  := fun (X Y X' Y' : Type)\\n         (f : X -> X')\\n         (g : Y -> Y')\\n       => reflexive (function_compose right g).
LHS: Example _sum_map_right\\n  : forall (X Y X' Y' : Type)\\n           (f : X -> X')\\n           (g : Y -> Y'),\\n      Equal (function_compose right g)\\n            (function_compose (sum_map f g) right)
RHS: fun (X Y X' Y' : Type)\\n         (f : X -> X')\\n         (g : Y -> Y')\\n       => reflexive (function_compose right g).
SortKey: Z

Label: e82fgb1k
Name: NA
Class: Vernacular
File: src/base/equal.v
Begin: 8
End: 9
Content: Require Import ufcoq.base.primitive.\\nRequire Import ufcoq.base.construct.
LHS: NA
RHS: NA
SortKey: T

Label: ybsrqsg4
Name: equal_compose
Class: Definition
File: src/base/equal.v
Begin: 17
End: 24
Content: Definition equal_compose\\n  : forall (X : Type) (x y z : X), Equal x y -> Equal y z -> Equal x z\\n  := fun (X : Type)\\n         (x y z : X)\\n       => let F : X -> Type := fun (a : X) => Equal a z\\n          in transport_inverse F.\\n\\nArguments equal_compose {X x y z} _ _.
LHS: Definition equal_compose\\n  : forall (X : Type) (x y z : X), Equal x y -> Equal y z -> Equal x z
RHS: fun (X : Type)\\n         (x y z : X)\\n       => let F : X -> Type := fun (a : X) => Equal a z\\n          in transport_inverse F.\\n\\nArguments equal_compose {X x y z} _ _.
SortKey: A

Label: ky5unwbq
Name: _equal_left_unit
Class: Example
File: src/base/equal.v
Begin: 28
End: 31
Content: Example _equal_left_unit\\n  : forall (X : Type) (x y : X) (p : Equal x y),\\n      Equal p (equal_compose (reflexive x) p)\\n  := fun (X : Type) (x y : X) (p : Equal x y) => reflexive p.
LHS: Example _equal_left_unit\\n  : forall (X : Type) (x y : X) (p : Equal x y),\\n      Equal p (equal_compose (reflexive x) p)
RHS: fun (X : Type) (x y : X) (p : Equal x y) => reflexive p.
SortKey: Z

Label: afizq40q
Name: equal_right_unit
Class: Definition
File: src/base/equal.v
Begin: 35
End: 49
Content: Definition equal_right_unit\\n  : forall (X : Type) (x y : X) (p : Equal x y),\\n      Equal p (equal_compose p (reflexive y))\\n  := fun (X : Type) (x : X)\\n       =>\\n         let\\n           F : forall (a : X), Equal x a -> Type\\n             := fun (a : X) (e : Equal x a)\\n                  => Equal e (equal_compose e (reflexive a))\\n         in let\\n           base : F x (reflexive x) := reflexive (reflexive x)\\n         in\\n           equal_induction x F base.\\n\\nArguments equal_right_unit {X x y} p.
LHS: Definition equal_right_unit\\n  : forall (X : Type) (x y : X) (p : Equal x y),\\n      Equal p (equal_compose p (reflexive y))
RHS: fun (X : Type) (x : X)\\n       =>\\n         let\\n           F : forall (a : X), Equal x a -> Type\\n             := fun (a : X) (e : Equal x a)\\n                  => Equal e (equal_compose e (reflexive a))\\n         in let\\n           base : F x (reflexive x) := reflexive (reflexive x)\\n         in\\n           equal_induction x F base.\\n\\nArguments equal_right_unit {X x y} p.
SortKey: A

Label: qj3cqa2b
Name: equal_associative
Class: Definition
File: src/base/equal.v
Begin: 53
End: 83
Content: Definition equal_associative\\n  : forall (X : Type)\\n           (w x y z : X)\\n           (p : Equal w x)\\n           (q : Equal x y)\\n           (r : Equal y z),\\n      Equal (equal_compose (equal_compose p q) r)\\n            (equal_compose p (equal_compose q r))\\n  := fun (X : Type)\\n         (w x y z : X)\\n         (p : Equal w x)\\n         (q : Equal x y)\\n         (r : Equal y z)\\n       =>\\n         let\\n           F : forall (a : X), Equal w a -> Type\\n             := fun (a : X) (i : Equal w a)\\n                  => forall (j : Equal a y),\\n                       Equal (equal_compose (equal_compose i j) r)\\n                             (equal_compose i (equal_compose j r))\\n         in let\\n           base : F w (reflexive w)\\n             := fun (j : Equal w y)\\n                  => reflexive (equal_compose j r)\\n         in let\\n           inductive : forall (a : X) (i : Equal w a), F a i\\n             := equal_induction w F base\\n         in\\n           inductive x p q.\\n\\nArguments equal_associative {X w x y z} p q r.
LHS: Definition equal_associative\\n  : forall (X : Type)\\n           (w x y z : X)\\n           (p : Equal w x)\\n           (q : Equal x y)\\n           (r : Equal y z),\\n      Equal (equal_compose (equal_compose p q) r)\\n            (equal_compose p (equal_compose q r))
RHS: fun (X : Type)\\n         (w x y z : X)\\n         (p : Equal w x)\\n         (q : Equal x y)\\n         (r : Equal y z)\\n       =>\\n         let\\n           F : forall (a : X), Equal w a -> Type\\n             := fun (a : X) (i : Equal w a)\\n                  => forall (j : Equal a y),\\n                       Equal (equal_compose (equal_compose i j) r)\\n                             (equal_compose i (equal_compose j r))\\n         in let\\n           base : F w (reflexive w)\\n             := fun (j : Equal w y)\\n                  => reflexive (equal_compose j r)\\n         in let\\n           inductive : forall (a : X) (i : Equal w a), F a i\\n             := equal_induction w F base\\n         in\\n           inductive x p q.\\n\\nArguments equal_associative {X w x y z} p q r.
SortKey: A

Label: smege15s
Name: equal_compose_left_equal
Class: Definition
File: src/base/equal.v
Begin: 87
End: 110
Content: Definition equal_compose_left_equal\\n  : forall (X : Type) (x y : X) (p p' : Equal x y),\\n      Equal p p'\\n        -> forall (z : X) (q : Equal y z),\\n             Equal (equal_compose p q) (equal_compose p' q)\\n  := fun (X : Type)\\n         (x y : X)\\n         (p p' : Equal x y)\\n         (u : Equal p p')\\n         (z : X)\\n         (q : Equal y z)\\n       =>\\n         let\\n           F : forall (i : Equal x y), Equal p i -> Type\\n             := fun (i  : Equal x y)\\n                  => constant_function (Equal (equal_compose p q)\\n                                              (equal_compose i q))\\n         in let\\n           base : F p (reflexive p)\\n             := reflexive (equal_compose p q)\\n         in\\n           equal_induction p F base p' u.\\n\\nArguments equal_compose_left_equal {X x y p p'} _ {z} q.
LHS: Definition equal_compose_left_equal\\n  : forall (X : Type) (x y : X) (p p' : Equal x y),\\n      Equal p p'\\n        -> forall (z : X) (q : Equal y z),\\n             Equal (equal_compose p q) (equal_compose p' q)
RHS: fun (X : Type)\\n         (x y : X)\\n         (p p' : Equal x y)\\n         (u : Equal p p')\\n         (z : X)\\n         (q : Equal y z)\\n       =>\\n         let\\n           F : forall (i : Equal x y), Equal p i -> Type\\n             := fun (i  : Equal x y)\\n                  => constant_function (Equal (equal_compose p q)\\n                                              (equal_compose i q))\\n         in let\\n           base : F p (reflexive p)\\n             := reflexive (equal_compose p q)\\n         in\\n           equal_induction p F base p' u.\\n\\nArguments equal_compose_left_equal {X x y p p'} _ {z} q.
SortKey: A

Label: g6ql88po
Name: equal_compose_right_equal
Class: Definition
File: src/base/equal.v
Begin: 114
End: 139
Content: Definition equal_compose_right_equal\\n  : forall (X : Type)\\n           (x y : X)\\n           (p : Equal x y)\\n           (z : X)\\n           (q q' : Equal y z),\\n      Equal q q' -> Equal (equal_compose p q) (equal_compose p q')\\n  := fun (X : Type)\\n         (x y : X)\\n         (p : Equal x y)\\n         (z : X)\\n         (q q' : Equal y z)\\n         (v : Equal q q')\\n       =>\\n         let\\n           F : forall (j : Equal y z), Equal q j -> Type\\n             := fun (j  : Equal y z)\\n                  => constant_function (Equal (equal_compose p q)\\n                                              (equal_compose p j))\\n         in let\\n           base : F q (reflexive q)\\n             := reflexive (equal_compose p q)\\n         in\\n           equal_induction q F base q' v.\\n\\nArguments equal_compose_right_equal {X x y} p {z q q'} _.
LHS: Definition equal_compose_right_equal\\n  : forall (X : Type)\\n           (x y : X)\\n           (p : Equal x y)\\n           (z : X)\\n           (q q' : Equal y z),\\n      Equal q q' -> Equal (equal_compose p q) (equal_compose p q')
RHS: fun (X : Type)\\n         (x y : X)\\n         (p : Equal x y)\\n         (z : X)\\n         (q q' : Equal y z)\\n         (v : Equal q q')\\n       =>\\n         let\\n           F : forall (j : Equal y z), Equal q j -> Type\\n             := fun (j  : Equal y z)\\n                  => constant_function (Equal (equal_compose p q)\\n                                              (equal_compose p j))\\n         in let\\n           base : F q (reflexive q)\\n             := reflexive (equal_compose p q)\\n         in\\n           equal_induction q F base q' v.\\n\\nArguments equal_compose_right_equal {X x y} p {z q q'} _.
SortKey: A

Label: npsmi0d4
Name: equal_compose_equal
Class: Definition
File: src/base/equal.v
Begin: 143
End: 166
Content: Definition equal_compose_equal\\n  : forall (X : Type)\\n           (x y z : X)\\n           (p p' : Equal x y)\\n           (q q' : Equal y z),\\n      Equal p p' -> Equal q q'\\n        -> Equal (equal_compose p q) (equal_compose p' q')\\n  := fun (X : Type)\\n         (x y z : X)\\n         (p p' : Equal x y)\\n         (q q' : Equal y z)\\n         (u : Equal p p')\\n         (v : Equal q q')\\n       =>\\n         let\\n           e : Equal (equal_compose p q) (equal_compose p' q)\\n             := equal_compose_left_equal u q\\n         in let\\n           f : Equal (equal_compose p' q) (equal_compose p' q')\\n             := equal_compose_right_equal p' v\\n         in\\n           equal_compose e f.\\n\\nArguments equal_compose_equal {X x y z p p' q q'} _ _.
LHS: Definition equal_compose_equal\\n  : forall (X : Type)\\n           (x y z : X)\\n           (p p' : Equal x y)\\n           (q q' : Equal y z),\\n      Equal p p' -> Equal q q'\\n        -> Equal (equal_compose p q) (equal_compose p' q')
RHS: fun (X : Type)\\n         (x y z : X)\\n         (p p' : Equal x y)\\n         (q q' : Equal y z)\\n         (u : Equal p p')\\n         (v : Equal q q')\\n       =>\\n         let\\n           e : Equal (equal_compose p q) (equal_compose p' q)\\n             := equal_compose_left_equal u q\\n         in let\\n           f : Equal (equal_compose p' q) (equal_compose p' q')\\n             := equal_compose_right_equal p' v\\n         in\\n           equal_compose e f.\\n\\nArguments equal_compose_equal {X x y z p p' q q'} _ _.
SortKey: A

Label: 37wczvy0
Name: equal_inverse
Class: Definition
File: src/base/equal.v
Begin: 174
End: 186
Content: Definition equal_inverse\\n  : forall (X : Type) (x y : X), Equal x y -> Equal y x\\n  := fun (X : Type) (x : X)\\n       =>\\n         let\\n           F : forall (y : X), Equal x y -> Type\\n             := fun (y : X) => constant_function (Equal y x)\\n         in let\\n           base : F x (reflexive x) := reflexive x\\n         in\\n           equal_induction x F base.\\n\\nArguments equal_inverse {X x y} _.
LHS: Definition equal_inverse\\n  : forall (X : Type) (x y : X), Equal x y -> Equal y x
RHS: fun (X : Type) (x : X)\\n       =>\\n         let\\n           F : forall (y : X), Equal x y -> Type\\n             := fun (y : X) => constant_function (Equal y x)\\n         in let\\n           base : F x (reflexive x) := reflexive x\\n         in\\n           equal_induction x F base.\\n\\nArguments equal_inverse {X x y} _.
SortKey: A

Label: fehutg63
Name: _equal_inverse_reflexive
Class: Example
File: src/base/equal.v
Begin: 190
End: 193
Content: Example _equal_inverse_reflexive\\n  : forall (X : Type) (x : X),\\n      Equal (reflexive x) (equal_inverse (reflexive x))\\n  := fun (X : Type) (x : X) => reflexive (reflexive x).
LHS: Example _equal_inverse_reflexive\\n  : forall (X : Type) (x : X),\\n      Equal (reflexive x) (equal_inverse (reflexive x))
RHS: fun (X : Type) (x : X) => reflexive (reflexive x).
SortKey: Z

Label: czd5dw60
Name: equal_left_inverse
Class: Definition
File: src/base/equal.v
Begin: 197
End: 212
Content: Definition equal_left_inverse\\n  : forall (X : Type) (x y : X) (p : Equal x y),\\n      Equal (reflexive y) (equal_compose (equal_inverse p) p)\\n  := fun (X : Type) (x : X)\\n       =>\\n         let\\n           F : forall (y : X), Equal x y -> Type\\n             := fun (y : X) (p : Equal x y)\\n                  => Equal (reflexive y)\\n                           (equal_compose (equal_inverse p) p)\\n         in let\\n           base : F x (reflexive x) := reflexive (reflexive x)\\n         in\\n           equal_induction x F base.\\n\\nArguments equal_left_inverse {X x y} p.
LHS: Definition equal_left_inverse\\n  : forall (X : Type) (x y : X) (p : Equal x y),\\n      Equal (reflexive y) (equal_compose (equal_inverse p) p)
RHS: fun (X : Type) (x : X)\\n       =>\\n         let\\n           F : forall (y : X), Equal x y -> Type\\n             := fun (y : X) (p : Equal x y)\\n                  => Equal (reflexive y)\\n                           (equal_compose (equal_inverse p) p)\\n         in let\\n           base : F x (reflexive x) := reflexive (reflexive x)\\n         in\\n           equal_induction x F base.\\n\\nArguments equal_left_inverse {X x y} p.
SortKey: A

Label: eay5nxer
Name: equal_right_inverse
Class: Definition
File: src/base/equal.v
Begin: 216
End: 231
Content: Definition equal_right_inverse\\n  : forall (X : Type) (x y : X) (p : Equal x y),\\n      Equal (reflexive x) (equal_compose p (equal_inverse p))\\n  := fun (X : Type) (x : X)\\n       =>\\n         let\\n           F : forall (y : X), Equal x y -> Type\\n             := fun (y : X) (p : Equal x y)\\n                  => Equal (reflexive x)\\n                           (equal_compose p (equal_inverse p))\\n         in let\\n           base : F x (reflexive x) := reflexive (reflexive x)\\n         in\\n           equal_induction x F base.\\n\\nArguments equal_right_inverse {X x y} p.
LHS: Definition equal_right_inverse\\n  : forall (X : Type) (x y : X) (p : Equal x y),\\n      Equal (reflexive x) (equal_compose p (equal_inverse p))
RHS: fun (X : Type) (x : X)\\n       =>\\n         let\\n           F : forall (y : X), Equal x y -> Type\\n             := fun (y : X) (p : Equal x y)\\n                  => Equal (reflexive x)\\n                           (equal_compose p (equal_inverse p))\\n         in let\\n           base : F x (reflexive x) := reflexive (reflexive x)\\n         in\\n           equal_induction x F base.\\n\\nArguments equal_right_inverse {X x y} p.
SortKey: A

Label: lxgjdap3
Name: equal_map
Class: Definition
File: src/base/equal.v
Begin: 239
End: 252
Content: Definition equal_map\\n  : forall (X Y : Type) (f : X -> Y) (x x' : X),\\n      Equal x x' -> Equal (f x) (f x')\\n  := fun (X Y : Type) (f : X -> Y) (x : X)\\n       =>\\n         let\\n           F : forall (x' : X), Equal x x' -> Type\\n             := fun (x' : X) => constant_function (Equal (f x) (f x'))\\n         in let\\n           base : F x (reflexive x) := reflexive (f x)\\n         in\\n           equal_induction x F base.\\n\\nArguments equal_map {X Y} f {x x'} _.
LHS: Definition equal_map\\n  : forall (X Y : Type) (f : X -> Y) (x x' : X),\\n      Equal x x' -> Equal (f x) (f x')
RHS: fun (X Y : Type) (f : X -> Y) (x : X)\\n       =>\\n         let\\n           F : forall (x' : X), Equal x x' -> Type\\n             := fun (x' : X) => constant_function (Equal (f x) (f x'))\\n         in let\\n           base : F x (reflexive x) := reflexive (f x)\\n         in\\n           equal_induction x F base.\\n\\nArguments equal_map {X Y} f {x x'} _.
SortKey: A

Label: udxkkzqg
Name: _equal_map_unital
Class: Example
File: src/base/equal.v
Begin: 256
End: 260
Content: Example _equal_map_unital\\n  : forall (X Y : Type) (f : X -> Y) (x : X),\\n      Equal (reflexive (f x)) (equal_map f (reflexive x))\\n  := fun (X Y : Type) (f : X -> Y) (x : X)\\n       => reflexive (reflexive (f x)).
LHS: Example _equal_map_unital\\n  : forall (X Y : Type) (f : X -> Y) (x : X),\\n      Equal (reflexive (f x)) (equal_map f (reflexive x))
RHS: fun (X Y : Type) (f : X -> Y) (x : X)\\n       => reflexive (reflexive (f x)).
SortKey: Z

Label: bul2i30n
Name: equal_map_multiplicative
Class: Definition
File: src/base/equal.v
Begin: 264
End: 287
Content: Definition equal_map_multiplicative\\n  : forall (X Y : Type)\\n           (f : X -> Y)\\n           (x1 x2 x3 : X)\\n           (p : Equal x1 x2)\\n           (q : Equal x2 x3),\\n      Equal (equal_map f (equal_compose p q))\\n            (equal_compose (equal_map f p) (equal_map f q))\\n  := fun (X Y : Type) (f : X -> Y) (x1 x2 x3 : X)\\n       =>\\n         let\\n           F : forall (a : X), Equal x1 a -> Type\\n             := fun (a : X) (p : Equal x1 a)\\n                  => forall (q : Equal a x3),\\n                       Equal (equal_map f (equal_compose p q))\\n                             (equal_compose (equal_map f p) (equal_map f q))\\n         in let\\n           base : F x1 (reflexive x1)\\n             := fun (q : Equal x1 x3)\\n                  => reflexive (equal_map f q)\\n         in\\n           equal_induction x1 F base x2.\\n\\nArguments equal_map_multiplicative {X Y} f {x1 x2 x3} p q.
LHS: Definition equal_map_multiplicative\\n  : forall (X Y : Type)\\n           (f : X -> Y)\\n           (x1 x2 x3 : X)\\n           (p : Equal x1 x2)\\n           (q : Equal x2 x3),\\n      Equal (equal_map f (equal_compose p q))\\n            (equal_compose (equal_map f p) (equal_map f q))
RHS: fun (X Y : Type) (f : X -> Y) (x1 x2 x3 : X)\\n       =>\\n         let\\n           F : forall (a : X), Equal x1 a -> Type\\n             := fun (a : X) (p : Equal x1 a)\\n                  => forall (q : Equal a x3),\\n                       Equal (equal_map f (equal_compose p q))\\n                             (equal_compose (equal_map f p) (equal_map f q))\\n         in let\\n           base : F x1 (reflexive x1)\\n             := fun (q : Equal x1 x3)\\n                  => reflexive (equal_map f q)\\n         in\\n           equal_induction x1 F base x2.\\n\\nArguments equal_map_multiplicative {X Y} f {x1 x2 x3} p q.
SortKey: A

Label: 5e7zp56e
Name: equal_map_inverse
Class: Definition
File: src/base/equal.v
Begin: 291
End: 307
Content: Definition equal_map_inverse\\n  : forall (X Y : Type) (f : X -> Y) (x x' : X) (p : Equal x x'),\\n      Equal (equal_map f (equal_inverse p))\\n            (equal_inverse (equal_map f p))\\n  := fun (X Y : Type) (f : X -> Y) (x : X)\\n       =>\\n         let\\n           F : forall (x' : X), Equal x x' -> Type\\n             := fun (x' : X) (p : Equal x x')\\n                  => Equal (equal_map f (equal_inverse p))\\n                           (equal_inverse (equal_map f p))\\n         in let\\n           base : F x (reflexive x) := reflexive (reflexive (f x))\\n         in\\n           equal_induction x F base.\\n\\nArguments equal_map_inverse {X Y} f {x x'} p.
LHS: Definition equal_map_inverse\\n  : forall (X Y : Type) (f : X -> Y) (x x' : X) (p : Equal x x'),\\n      Equal (equal_map f (equal_inverse p))\\n            (equal_inverse (equal_map f p))
RHS: fun (X Y : Type) (f : X -> Y) (x : X)\\n       =>\\n         let\\n           F : forall (x' : X), Equal x x' -> Type\\n             := fun (x' : X) (p : Equal x x')\\n                  => Equal (equal_map f (equal_inverse p))\\n                           (equal_inverse (equal_map f p))\\n         in let\\n           base : F x (reflexive x) := reflexive (reflexive (f x))\\n         in\\n           equal_induction x F base.\\n\\nArguments equal_map_inverse {X Y} f {x x'} p.
SortKey: A

Label: omtjvrai
Name: equal_left_cancel
Class: Definition
File: src/base/equal.v
Begin: 315
End: 336
Content: Definition equal_left_cancel\\n  : forall (X : Type) (x y z : X) (p : Equal x y) (q q' : Equal y z),\\n      Equal (equal_compose p q) (equal_compose p q') -> Equal q q'\\n  := fun (X : Type) (x y z : X) (p : Equal x y) (q q' : Equal y z)\\n       =>\\n         let\\n           F : forall (a : X), Equal x a -> Type\\n             := fun (a : X) (i : Equal x a)\\n                  => forall (j j' :  Equal a z),\\n                       Equal (equal_compose i j) (equal_compose i j')\\n                         -> Equal j j'\\n         in let\\n           base : F x (reflexive x)\\n             := fun (j j' : Equal x z)\\n                  => @identity_function (Equal j j')\\n         in let\\n           inductive : forall (a : X) (i : Equal x a), F a i\\n             := equal_induction x F base\\n         in\\n           inductive y p q q'.\\n\\nArguments equal_left_cancel {X x y z} p q q' _.
LHS: Definition equal_left_cancel\\n  : forall (X : Type) (x y z : X) (p : Equal x y) (q q' : Equal y z),\\n      Equal (equal_compose p q) (equal_compose p q') -> Equal q q'
RHS: fun (X : Type) (x y z : X) (p : Equal x y) (q q' : Equal y z)\\n       =>\\n         let\\n           F : forall (a : X), Equal x a -> Type\\n             := fun (a : X) (i : Equal x a)\\n                  => forall (j j' :  Equal a z),\\n                       Equal (equal_compose i j) (equal_compose i j')\\n                         -> Equal j j'\\n         in let\\n           base : F x (reflexive x)\\n             := fun (j j' : Equal x z)\\n                  => @identity_function (Equal j j')\\n         in let\\n           inductive : forall (a : X) (i : Equal x a), F a i\\n             := equal_induction x F base\\n         in\\n           inductive y p q q'.\\n\\nArguments equal_left_cancel {X x y z} p q q' _.
SortKey: A

Label: 865g4mt7
Name: equal_left_remove
Class: Definition
File: src/base/equal.v
Begin: 340
End: 365
Content: Definition equal_left_remove\\n  : forall (X : Type)\\n           (x y : X)\\n           (p p' : Equal x y),\\n      Equal p p'\\n        -> forall (z : X) (q q' : Equal y z),\\n             Equal (equal_compose p q) (equal_compose p' q')\\n               -> Equal q q'\\n  := fun (X : Type)\\n         (x y : X)\\n         (p p' : Equal x y)\\n         (u : Equal p p')\\n         (z : X)\\n         (q q' : Equal y z)\\n         (e : Equal (equal_compose p q) (equal_compose p' q'))\\n       =>\\n         let\\n           e1 : Equal (equal_compose p q') (equal_compose p' q')\\n              := equal_compose_left_equal u q'\\n         in let\\n           e2 : Equal (equal_compose p q) (equal_compose p q')\\n              := equal_compose e (equal_inverse e1)\\n         in\\n           equal_left_cancel p q q' e2.\\n\\nArguments equal_left_remove {X x y p p'} _ {z} q q' _.
LHS: Definition equal_left_remove\\n  : forall (X : Type)\\n           (x y : X)\\n           (p p' : Equal x y),\\n      Equal p p'\\n        -> forall (z : X) (q q' : Equal y z),\\n             Equal (equal_compose p q) (equal_compose p' q')\\n               -> Equal q q'
RHS: fun (X : Type)\\n         (x y : X)\\n         (p p' : Equal x y)\\n         (u : Equal p p')\\n         (z : X)\\n         (q q' : Equal y z)\\n         (e : Equal (equal_compose p q) (equal_compose p' q'))\\n       =>\\n         let\\n           e1 : Equal (equal_compose p q') (equal_compose p' q')\\n              := equal_compose_left_equal u q'\\n         in let\\n           e2 : Equal (equal_compose p q) (equal_compose p q')\\n              := equal_compose e (equal_inverse e1)\\n         in\\n           equal_left_cancel p q q' e2.\\n\\nArguments equal_left_remove {X x y p p'} _ {z} q q' _.
SortKey: A

Label: 8gh9140h
Name: equal_right_cancel
Class: Definition
File: src/base/equal.v
Begin: 369
End: 400
Content: Definition equal_right_cancel\\n  : forall (X : Type) (x y z : X) (p p' : Equal x y) (q : Equal y z),\\n      Equal (equal_compose p q) (equal_compose p' q) -> Equal p p'\\n  := fun (X : Type) (x y z : X) (p p' : Equal x y) (q : Equal y z)\\n       =>\\n         let\\n           F : forall (a : X), Equal y a -> Type\\n             := fun (a : X) (j : Equal y a)\\n                  => forall (i i' :  Equal x y),\\n                       Equal (equal_compose i j) (equal_compose i' j)\\n                         -> Equal i i'\\n         in let\\n           base : F y (reflexive y)\\n             := fun (i i' : Equal x y)\\n                    (u : Equal (equal_compose i (reflexive y))\\n                               (equal_compose i' (reflexive y)))\\n                  =>\\n                    let\\n                      e1 : Equal i (equal_compose i (reflexive y))\\n                         := equal_right_unit i\\n                    in let\\n                      e2 : Equal (equal_compose i' (reflexive y)) i'\\n                         := equal_inverse (equal_right_unit i')\\n                    in\\n                      equal_compose (equal_compose e1 u) e2\\n         in let\\n           inductive : forall (a : X) (j : Equal y a), F a j\\n             := equal_induction y F base\\n         in\\n           inductive z q p p'.\\n\\nArguments equal_right_cancel {X x y z} p p' q _.
LHS: Definition equal_right_cancel\\n  : forall (X : Type) (x y z : X) (p p' : Equal x y) (q : Equal y z),\\n      Equal (equal_compose p q) (equal_compose p' q) -> Equal p p'
RHS: fun (X : Type) (x y z : X) (p p' : Equal x y) (q : Equal y z)\\n       =>\\n         let\\n           F : forall (a : X), Equal y a -> Type\\n             := fun (a : X) (j : Equal y a)\\n                  => forall (i i' :  Equal x y),\\n                       Equal (equal_compose i j) (equal_compose i' j)\\n                         -> Equal i i'\\n         in let\\n           base : F y (reflexive y)\\n             := fun (i i' : Equal x y)\\n                    (u : Equal (equal_compose i (reflexive y))\\n                               (equal_compose i' (reflexive y)))\\n                  =>\\n                    let\\n                      e1 : Equal i (equal_compose i (reflexive y))\\n                         := equal_right_unit i\\n                    in let\\n                      e2 : Equal (equal_compose i' (reflexive y)) i'\\n                         := equal_inverse (equal_right_unit i')\\n                    in\\n                      equal_compose (equal_compose e1 u) e2\\n         in let\\n           inductive : forall (a : X) (j : Equal y a), F a j\\n             := equal_induction y F base\\n         in\\n           inductive z q p p'.\\n\\nArguments equal_right_cancel {X x y z} p p' q _.
SortKey: A

Label: sqhuo1hf
Name: equal_right_remove
Class: Definition
File: src/base/equal.v
Begin: 404
End: 430
Content: Definition equal_right_remove\\n  : forall (X : Type)\\n           (x y : X)\\n           (p p' : Equal x y)\\n           (z : X)\\n           (q q' : Equal y z),\\n      Equal q q'\\n        -> Equal (equal_compose p q) (equal_compose p' q')\\n          -> Equal p p'\\n  := fun (X : Type)\\n         (x y : X)\\n         (p p' : Equal x y)\\n         (z : X)\\n         (q q' : Equal y z)\\n         (v : Equal q q')\\n         (e : Equal (equal_compose p q) (equal_compose p' q'))\\n       =>\\n         let\\n           e1 : Equal (equal_compose p' q) (equal_compose p' q')\\n              := equal_compose_right_equal p' v\\n         in let\\n           e2 : Equal (equal_compose p q) (equal_compose p' q)\\n              := equal_compose e (equal_inverse e1)\\n         in\\n           equal_right_cancel p p' q e2.\\n\\nArguments equal_right_remove {X x y} p p' {z} {q q'} _ _.
LHS: Definition equal_right_remove\\n  : forall (X : Type)\\n           (x y : X)\\n           (p p' : Equal x y)\\n           (z : X)\\n           (q q' : Equal y z),\\n      Equal q q'\\n        -> Equal (equal_compose p q) (equal_compose p' q')\\n          -> Equal p p'
RHS: fun (X : Type)\\n         (x y : X)\\n         (p p' : Equal x y)\\n         (z : X)\\n         (q q' : Equal y z)\\n         (v : Equal q q')\\n         (e : Equal (equal_compose p q) (equal_compose p' q'))\\n       =>\\n         let\\n           e1 : Equal (equal_compose p' q) (equal_compose p' q')\\n              := equal_compose_right_equal p' v\\n         in let\\n           e2 : Equal (equal_compose p q) (equal_compose p' q)\\n              := equal_compose e (equal_inverse e1)\\n         in\\n           equal_right_cancel p p' q e2.\\n\\nArguments equal_right_remove {X x y} p p' {z} {q q'} _ _.
SortKey: A

Label: x71kqflr
Name: equal_left_unit_unique
Class: Definition
File: src/base/equal.v
Begin: 438
End: 444
Content: Definition equal_left_unit_unique\\n  : forall (X : Type) (x y : X) (p : Equal x x) (q : Equal x y),\\n      Equal q (equal_compose p q) -> Equal (reflexive x) p\\n  := fun (X : Type) (x y : X) (p : Equal x x) (q : Equal x y)\\n       => equal_right_cancel (reflexive x) p q.\\n\\nArguments equal_left_unit_unique {X x y} p {q} _.
LHS: Definition equal_left_unit_unique\\n  : forall (X : Type) (x y : X) (p : Equal x x) (q : Equal x y),\\n      Equal q (equal_compose p q) -> Equal (reflexive x) p
RHS: fun (X : Type) (x y : X) (p : Equal x x) (q : Equal x y)\\n       => equal_right_cancel (reflexive x) p q.\\n\\nArguments equal_left_unit_unique {X x y} p {q} _.
SortKey: A

Label: m1jqzny4
Name: equal_right_unit_unique
Class: Definition
File: src/base/equal.v
Begin: 448
End: 467
Content: Definition equal_right_unit_unique\\n  : forall (X : Type) (x y : X) (p : Equal x y) (q : Equal y y),\\n      Equal p (equal_compose p q) -> Equal (reflexive y) q\\n  := fun (X : Type)\\n         (x y : X)\\n         (p : Equal x y)\\n         (q : Equal y y)\\n         (u : Equal p (equal_compose p q))\\n       =>\\n         let\\n           e : Equal p (equal_compose p (reflexive y))\\n             := equal_right_unit p\\n         in let\\n           f : Equal (equal_compose p (reflexive y))\\n                     (equal_compose p q)\\n             := equal_compose (equal_inverse e) u\\n         in\\n           equal_left_cancel p (reflexive y) q f.\\n\\nArguments equal_right_unit_unique {X x y p} q _.
LHS: Definition equal_right_unit_unique\\n  : forall (X : Type) (x y : X) (p : Equal x y) (q : Equal y y),\\n      Equal p (equal_compose p q) -> Equal (reflexive y) q
RHS: fun (X : Type)\\n         (x y : X)\\n         (p : Equal x y)\\n         (q : Equal y y)\\n         (u : Equal p (equal_compose p q))\\n       =>\\n         let\\n           e : Equal p (equal_compose p (reflexive y))\\n             := equal_right_unit p\\n         in let\\n           f : Equal (equal_compose p (reflexive y))\\n                     (equal_compose p q)\\n             := equal_compose (equal_inverse e) u\\n         in\\n           equal_left_cancel p (reflexive y) q f.\\n\\nArguments equal_right_unit_unique {X x y p} q _.
SortKey: A

### End of file
